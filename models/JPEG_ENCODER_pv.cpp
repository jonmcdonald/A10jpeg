
/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file contains the PV class for JPEG_ENCODER.
//* This is a template file: You may modify this file to implement the 
//* behavior of your component. 
//* 
//* Model Builder version: 4.1.0
//* Generated on: Jan. 27, 2016 06:22:45 PM, (user: mbradley)
//*>



#include "JPEG_ENCODER_pv.h"
#include <iostream>


using namespace sc_core;
using namespace sc_dt;
using namespace std;

//constructor
JPEG_ENCODER_pv::JPEG_ENCODER_pv(sc_module_name module_name) 
  : JPEG_ENCODER_pv_base(module_name) 
   ,mbFifo(1)
   ,jpegRunning(0)
   ,m_bitstream("jpeg_out.jpg") // enable jpeg file write in jpeg_algorithm/bitstream.h

{
    SC_THREAD(thread);
} 

// Read callback for status register.
// The value that this function returns, will be returned to the initiator port that requested its value.
unsigned int JPEG_ENCODER_pv::cb_read_status() {
    unsigned tmp;
    tmp = status = (irq.read() << 1) | jpegRunning;
    return tmp; // status register may not be yet updated
}
 
// Read callback for start register.
// The value that this function returns, will be returned to the initiator port that requested its value.
unsigned int JPEG_ENCODER_pv::cb_read_start() {
  return start;
}
  
// Write callback for start register.
// The newValue has been already assigned to the start register.
void JPEG_ENCODER_pv::cb_write_start(unsigned int newValue) 
{
    if ((start &1) == 1) {
        //cout <<name()<<" @ "<<sc_time_stamp()<<" JPEG start bit written"<<endl;
        mbFifo.put(1);
    }
    else if ((start &1) == 0) {
        //cout <<name()<<" @ "<<sc_time_stamp()<<" JPEG irq acknowledge written"<<endl;
        irq.write(0);
    }
}

void JPEG_ENCODER_pv::thread()
{
    unsigned numBlocks;
    unsigned outputCount;
    unsigned dmaWriteSize;

    while (1) {
        mbFifo.peek(); // block/wait until start bit is written

        outputlength    = 0;
        outputCount     = 0;
        jpegRunning     = 1;
        dmaReadAddr     = 0;
        dmaWriteAddr    = outputaddr;
        width           = (input_w_h_size >> 16) & 0x3FFF; // 14 bits
        height          = input_w_h_size & 0x1FFF;         // 13 bits
        numBlocks       = (width*height+BLOCK_SIZE-1) / BLOCK_SIZE;
        if (numBlocks != width*height/BLOCK_SIZE)
            cout <<name()<<" @ "<<sc_time_stamp()<<" ERROR: bmp width*height not a multiple of BLOCK_SIZE ("<< BLOCK_SIZE <<")"<<endl;

        cout <<name()<<" @ "<<sc_time_stamp()<<" Starting JPEG compression input_w_h_size= "<<hex<< input_w_h_size <<" width= "<<dec<< width <<" height= "<< height <<endl;
        // reset the jpeg encoder
        pixelpipe(true,blocktype, rgbstream, hufstream);  // Does reset only

        // JPEG Preamble
        m_bitstream.writepreamble(height, width);
        
        // DMA Burst out preamble
        //printf("preamble write :");
        while (m_bitstream.get_resultSize() >= WRITE_BLOCK_SIZE) {
            for (int i=0; i<WRITE_BLOCK_SIZE; i++) {
                imageWriteData[i] = m_bitstream.get_resultByte();
                //printf(" %02X",imageWriteData[i]);
            }
            //printf("\n");
            master_write(dmaWriteAddr , imageWriteData, WRITE_BLOCK_SIZE);
            dmaWriteAddr += WRITE_BLOCK_SIZE;
        }
        
        // Loop through each input block and process
        for (unsigned block=0; block<numBlocks; block++)
        {
            //cout <<name()<<" @ "<<sc_time_stamp()<<" processing block "<<dec<< block <<endl;

            // Read in Bursts of READ_BLOCK_SIZE 
            for (int x=0; x<BLOCK_SIZE/READ_BLOCK_SIZE; x++) {
                master_read(inputaddr+dmaReadAddr+READ_BLOCK_SIZE*x*4, (char *) &(imageReadData[x*READ_BLOCK_SIZE]), READ_BLOCK_SIZE*4);
            }
            dmaReadAddr += BLOCK_SIZE*4; // 4 bytes for each rgb pixel in the block

            for (int i=0; i<BLOCK_SIZE; i++) {
                rgb[i].r = (imageReadData[i] >> 16) & 0xFF;
                rgb[i].g = (imageReadData[i] >>  8) & 0xFF;
                rgb[i].b = (imageReadData[i] >>  0) & 0xFF;
                //printf("rgbIn: ,0x00%02X%02X%02X\n",rgb[i].r, rgb[i].g, rgb[i].b);
            }

            // process same input data as Y, Cb and Cr blocks, one after the other
            for (int type = 0; type <= 2; type++) 
            {
                //cout <<name()<<" @ "<<sc_time_stamp()<<" processing block "<<dec<< block <<" type "<< type <<endl;

                blocktype.write(type);
                //printf("BBB %d %d :",block,type);
                for (int i=0; i<BLOCK_SIZE; i++) {
                    //printf(" %02X%02X%02X",rgb[i].r,rgb[i].g,rgb[i].b);
                    rgbstream.write(rgb[i]);
                }
                //printf("\n");
            
                pixelpipe(false,blocktype, rgbstream, hufstream);  // The JPEG algorithm

                for (int i=0; i<BLOCK_SIZE; i++) 
                    codes[i] = hufstream.read();
            
                // write out the bitstream
                for (int k=0; k<BLOCK_SIZE; k++) {
                    m_bitstream.write(codes[k].size, codes[k].code);
                }
            }

            // DMA out data in bursts
            while (m_bitstream.get_resultSize() >= WRITE_BLOCK_SIZE) {
                //printf("block write %d :",block);
                for (int i=0; i<WRITE_BLOCK_SIZE; i++) {
                    imageWriteData[i] = m_bitstream.get_resultByte();
                    //printf(" %02X",imageWriteData[i]);
                }
                //printf("\n");
                master_write(dmaWriteAddr , imageWriteData, WRITE_BLOCK_SIZE);
                dmaWriteAddr += WRITE_BLOCK_SIZE;
            }
        }
        // write out trailing info for the jpeg
        m_bitstream.writepostscript();

        // probably not a full block available, but check
        while (m_bitstream.get_resultSize() >= WRITE_BLOCK_SIZE) {
            //printf("post write :");
            for (unsigned i=0; i<WRITE_BLOCK_SIZE; i++) {
                imageWriteData[i] = m_bitstream.get_resultByte();
                //printf(" %02X",imageWriteData[i]);
            }    
            //printf("\n");
            master_write(dmaWriteAddr , imageWriteData, WRITE_BLOCK_SIZE);
            dmaWriteAddr += WRITE_BLOCK_SIZE;
        }

        // DMA remaining bytes
        //printf("last bytes write :");
        dmaWriteSize = m_bitstream.get_resultSize(); 
        if (dmaWriteSize > 0) 
        {
            for (unsigned i=0; i<dmaWriteSize; i++) {
                imageWriteData[i] = m_bitstream.get_resultByte();
                //printf(" %02X",imageWriteData[i]);
            }
            //printf("\n");
            master_write(dmaWriteAddr , imageWriteData, dmaWriteSize);
        }
        
        jpegRunning   = 0;
        outputlength  = m_bitstream.get_outputlength();
        cout <<name()<<" @ "<<sc_time_stamp()<<" Final outputlength = "<<dec<< m_bitstream.get_outputlength() <<endl;
        irq.write(1);
        
        mbFifo.get();  // release Fifo, Done.
    }
}
    
//============================================== 
// Read callback for slave port.
// Returns true when successful.
bool JPEG_ENCODER_pv::slave_callback_read(mb_address_type address, unsigned char* data, unsigned size) {
  return true;
}
// Write callback for slave port.
// Returns true when successful.
bool JPEG_ENCODER_pv::slave_callback_write(mb_address_type address, unsigned char* data, unsigned size) {
  return true;
} 
unsigned JPEG_ENCODER_pv::slave_callback_read_dbg(mb_address_type address, unsigned char* data, unsigned size) {
  return 0;
} 
unsigned JPEG_ENCODER_pv::slave_callback_write_dbg(mb_address_type address, unsigned char* data, unsigned size) {
  return 0;
} 
bool JPEG_ENCODER_pv::slave_get_direct_memory_ptr(mb_address_type address, tlm::tlm_dmi& dmiData) {
  return false;
}
void JPEG_ENCODER_pv::cb_transport_dbg_status(tlm::tlm_generic_payload& trans) {}
void JPEG_ENCODER_pv::cb_transport_dbg_start(tlm::tlm_generic_payload& trans) {}
