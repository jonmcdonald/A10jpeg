
/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file contains the PV class for vivy_jpeg.
//* This is a template file: You may modify this file to implement the 
//* behavior of your component. 
//* 
//* Model Builder version: 4.1.0
//* Generated on: Jan. 27, 2016 02:55:26 PM, (user: mbradley)
//*>


#include "vivy_jpeg_pv.h"
#include <iostream>
#include <string>

//#define VIVY_DEBUG


//constructor
vivy_jpeg_pv::vivy_jpeg_pv(sc_module_name module_name) 
  : vivy_jpeg_pv_base(module_name)
{
    if (! vivy_disable) 
    {
        jpeg_dma_v2r_socket_to_uvmc = new  tlm_utils::simple_initiator_socket<vivy_jpeg_pv>("jpeg_dma_v2r_socket_to_uvmc"); 
        #ifdef ENABLE_jpeg_dma_v2r_DEBUG_SOCKET 
          jpeg_dma_v2r_debug_socket_to_uvmc = new  tlm_utils::simple_initiator_socket<vivy_jpeg_pv>("jpeg_dma_v2r_debug_socket_to_uvmc"); 
        #endif
        jpeg_irq_v2r_socket_to_uvmc = new  tlm_utils::simple_initiator_socket<vivy_jpeg_pv>("jpeg_irq_v2r_socket_to_uvmc");
        jpeg_regs_r2v_socket_from_uvmc = new  tlm_utils::simple_target_socket<vivy_jpeg_pv>("jpeg_regs_r2v_socket_from_uvmc");

        // Bindings to UVM Connect (uvmcName must be unique)
        string uvmcName;
        string instName = name();
        instName.erase(instName.length()-2,2); 

        // use colon for running Vista in a separate process, as well as single process
        string uvmcColon_prefix = ":uvmc_"; 

        // store hierarchical port name in 'uvmcConnectNames' for printf
        // Also store uvmc connect string in 'uvmcConnectNames' for uvmc_connect call
        // Use default uvmc connect string, or value from parameters.txt
        uvmcConnectNames.push_back(string(instName + string("jpeg_irq_v2r"))); 
        if (*uvmc_jpeg_irq_v2r == 0) 
            uvmcName = uvmcColon_prefix + string("jpeg_irq_v2r");
        else 
            uvmcName = string(uvmc_jpeg_irq_v2r);
        uvmcConnectNames.push_back(uvmcName);  
        // Using template parameter "<uvmc_xl_converter<tlm_generic_payload> >" enables "Fast Packers" 
        uvmc_connect <uvmc_xl_converter<tlm_generic_payload> > (*jpeg_irq_v2r_socket_to_uvmc, uvmcName);

        uvmcConnectNames.push_back(string(instName + string("jpeg_dma_v2r")));
        if (*uvmc_jpeg_dma_v2r == 0) 
            uvmcName = uvmcColon_prefix + string("jpeg_dma_v2r");
        else 
            uvmcName = string(uvmc_jpeg_dma_v2r);
        uvmcConnectNames.push_back(uvmcName);  
        uvmc_connect <uvmc_xl_converter<tlm_generic_payload> > (*jpeg_dma_v2r_socket_to_uvmc, uvmcName);
        
        #ifdef ENABLE_jpeg_dma_v2r_DEBUG_SOCKET 
          uvmcConnectNames.push_back(string(instName + string("dbg_jpeg_dma_v2r")));
          if (*uvmc_dbg_jpeg_dma_v2r == 0) 
              uvmcName = uvmcColon_prefix + string("dbg_jpeg_dma_v2r");
          else 
              uvmcName = string(uvmc_dbg_jpeg_dma_v2r);
          uvmcConnectNames.push_back(uvmcName);  
          uvmc_connect <uvmc_xl_converter<tlm_generic_payload> > (*jpeg_dma_v2r_debug_socket_to_uvmc, uvmcName);
        #endif

        uvmcConnectNames.push_back(string(instName + string("jpeg_regs_r2v")));
        if (*uvmc_jpeg_regs_r2v == 0) 
            uvmcName = uvmcColon_prefix + string("jpeg_regs_r2v");
        else 
            uvmcName = string(uvmc_jpeg_regs_r2v);
        uvmcConnectNames.push_back(uvmcName);  
        uvmc_connect <uvmc_xl_converter<tlm_generic_payload> > (*jpeg_regs_r2v_socket_from_uvmc, uvmcName); 

        // register simple_target_socket transport callbacks
        jpeg_regs_r2v_socket_from_uvmc->register_b_transport( this, &vivy_jpeg_pv::jpeg_regs_r2v_b_transport);
        jpeg_regs_r2v_socket_from_uvmc->register_nb_transport_fw( this, &vivy_jpeg_pv::jpeg_regs_r2v_nb_transport_fw);

        jpeg_irq_v2r_socket_to_uvmc->register_nb_transport_bw( this, &vivy_jpeg_pv::jpeg_irq_v2r_nb_transport_bw);

        jpeg_dma_v2r_socket_to_uvmc->register_nb_transport_bw( this, &vivy_jpeg_pv::jpeg_dma_v2r_nb_transport_bw);

    
        for (vector<string>::iterator it=uvmcConnectNames.begin(); it != uvmcConnectNames.end(); it=it+2) 
            cout <<" VistaVerify UVM Connect path for pin '"<< *(it) <<"' => '"<< *(it+1) <<"'"<<endl;
    } 
}


  
  ////////////////////////////////////////////
  // Slave bus Transaction forwarded to UVMC
  //////////////////////////////////////////// 
  void vivy_jpeg_pv::jpeg_dma_v2r_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, sc_core::sc_time& t) 
  {
    if (trans.get_data_length() == 0) {
        cout <<name()<<" @ "<<sc_time_stamp()<<" jpeg_dma_v2r_callback: Ignoring 0 length transaction "
             <<" addr="<<hex<<showbase<< trans.get_address() <<" streaming_width="<<dec<< trans.get_streaming_width()
             <<" data_length="<< trans.get_data_length() <<" is_write="<< trans.is_write() <<endl;
        return;
    }

    (*jpeg_dma_v2r_socket_to_uvmc)->b_transport(trans, t);

    #if (defined VIVY_DEBUG || 0)
    if (trans.is_write())
        cout <<name()<<" @ "<<sc_time_stamp()<<" jpeg_dma_v2r_callback: WRITE addr="<<hex<<showbase<< trans.get_address() 
                     <<" data[3:0]="<< *(unsigned int *)trans.get_data_ptr() <<" size="<<dec<< trans.get_data_length() <<endl;
    else
        cout <<name()<<" @ "<<sc_time_stamp()<<" jpeg_dma_v2r_callback: READ  addr="<<hex<<showbase<< trans.get_address() 
                     <<" data[3:0]="<< *(unsigned int *)trans.get_data_ptr() <<" size="<<dec<< trans.get_data_length() <<endl;
    #endif

    if (trans.get_response_status() == tlm::TLM_INCOMPLETE_RESPONSE)
        trans.set_response_status(TLM_OK_RESPONSE);  // Not sure if this needed...
  } 

  tlm::tlm_sync_enum vivy_jpeg_pv::jpeg_dma_v2r_nb_transport_bw(tlm::tlm_generic_payload& trans, tlm::tlm_phase& phase, sc_core::sc_time& delay) 
  { 
    cout <<name()<<" @ "<<sc_time_stamp()<<" WARNING: Hello from jpeg_dma_v2r_nb_transport_bw() currently does nothing...\n";
    phase = END_RESP;
    trans.set_response_status(TLM_COMMAND_ERROR_RESPONSE);
    return(TLM_COMPLETED);
  } 

  ////////////////////////////////////////////
  // signal in Transaction from Vista to UVMC
  //////////////////////////////////////////// 
  void vivy_jpeg_pv::jpeg_irq_v2r_callback()
  {
    sc_core::sc_time    t    = SC_ZERO_TIME;
    tlm::tlm_phase      phase= BEGIN_REQ;
    unsigned            size = getSystemCBaseModel()->get_port_width(jpeg_irq_v2r_idx);
    unsigned long long  data = 0;

    data = jpeg_irq_v2r.read();

    jpeg_irq_v2r_trans.set_data_ptr(reinterpret_cast<unsigned char*>(&data));
    jpeg_irq_v2r_trans.set_data_length(size);
    jpeg_irq_v2r_trans.set_write();
    jpeg_irq_v2r_trans.set_address(0);
    jpeg_irq_v2r_trans.set_streaming_width(jpeg_irq_v2r_trans.get_data_length());
    jpeg_irq_v2r_trans.set_byte_enable_ptr(0);
    jpeg_irq_v2r_trans.set_byte_enable_length(0);
    jpeg_irq_v2r_trans.set_dmi_allowed(0);


    #if (defined VIVY_DEBUG || 0)
        cout <<name()<<" @ "<<sc_time_stamp()<<" jpeg_irq_v2r_callback: WRITE data="
             <<hex<< *(unsigned *)jpeg_irq_v2r_trans.get_data_ptr() <<" sizeBytes= "<<dec<< size <<endl;
    #endif

    (*jpeg_irq_v2r_socket_to_uvmc)->nb_transport_fw(jpeg_irq_v2r_trans, phase, t);
  } 
    
  // Unused nb_transport_bw for signals sent to UVMC (other side should early terminate the transaction)
  tlm::tlm_sync_enum vivy_jpeg_pv::jpeg_irq_v2r_nb_transport_bw(tlm::tlm_generic_payload& trans, tlm::tlm_phase& phase, sc_core::sc_time& delay) { 
      cout <<name()<<" @ "<<sc_time_stamp()<<" WARNING: Hello from jpeg_irq_v2r_nb_transport_bw() that shouldn't have been called...\n";
      return(TLM_COMPLETED);
  } 

  //////////////////////////////////////////////////
  // Master bus Transaction from UVMC
  ////////////////////////////////////////////////// 
  void vivy_jpeg_pv::jpeg_regs_r2v_b_transport(tlm::tlm_generic_payload& trans, sc_core::sc_time& delay)
  {
    jpeg_regs_r2v_transport(trans);

    #if (defined VIVY_DEBUG || 0)
    if (trans.is_write())
        cout <<name()<<" @ "<<sc_time_stamp()<<" jpeg_regs_r2v_b_transport: WRITE addr="<<hex<<showbase<< trans.get_address() 
                     <<" data[3:0]="<< *(unsigned int *)trans.get_data_ptr() <<" size="<<dec<< trans.get_data_length() <<endl;
    else
        cout <<name()<<" @ "<<sc_time_stamp()<<" jpeg_regs_r2v_b_transport: READ  addr="<<hex<<showbase<< trans.get_address() 
                     <<" data[3:0]="<< *(unsigned int *)trans.get_data_ptr() <<" size="<<dec<< trans.get_data_length() <<endl;
    #endif

    trans.set_response_status(TLM_OK_RESPONSE);
  } 
  
  tlm::tlm_sync_enum vivy_jpeg_pv::jpeg_regs_r2v_nb_transport_fw(tlm::tlm_generic_payload& trans, tlm::tlm_phase& phase, sc_core::sc_time& delay)
  {
    cout <<name()<<" @ "<<sc_time_stamp()<<" WARNING: Hello from jpeg_regs_r2v_nb_transport_fw() is NOT yet implemented...\n";
    #if (defined VIVY_DEBUG || 0)
    if (trans.is_write())
        cout <<name()<<" @ "<<sc_time_stamp()<<" jpeg_regs_r2v_nb_transport_fw: WRITE addr="<<hex<<showbase<< trans.get_address() 
                     <<" data[3:0]="<< *(unsigned int *)trans.get_data_ptr() <<" size="<<dec<< trans.get_data_length() <<endl;
    else
        cout <<name()<<" @ "<<sc_time_stamp()<<" jpeg_regs_r2v_nb_transport_fw: READ  addr="<<hex<<showbase<< trans.get_address() 
                     <<" data[3:0]="<< *(unsigned int *)trans.get_data_ptr() <<" size="<<dec<< trans.get_data_length() <<endl;
    #endif
    trans.set_response_status(TLM_COMMAND_ERROR_RESPONSE);
    return(TLM_COMPLETED);
  }  

    

/////////////////////////////////////////////////////
// Read Debug callback for jpeg_dma_v2r 
///////////////////////////////////////////////////// 
unsigned vivy_jpeg_pv::jpeg_dma_v2r_callback_read_dbg(config::uint64 address, unsigned char* data, unsigned size) 
{ 
    // Call nb_transport_fw in UVM-Connect to mimic SystemC TLM Debug call.
    // SystemVerilog implementation of nb_transport_fw should terminate it early by specifying a return phase of "END_RESP"
    tlm::tlm_generic_payload trans;
    tlm::tlm_phase           phase = BEGIN_REQ;
    sc_time                  delay = SC_ZERO_TIME;

    trans.set_read();
    trans.set_address(address);
    trans.set_data_ptr(data);
    trans.set_data_length(size);
    trans.set_streaming_width(size);

    #ifdef ENABLE_jpeg_dma_v2r_DEBUG_SOCKET 
      (*jpeg_dma_v2r_debug_socket_to_uvmc)->nb_transport_fw(trans, phase, delay);

      #if (defined VIVY_DEBUG || 0)
        cout <<name()<<" @ "<<sc_time_stamp()<<" jpeg_dma_v2r_callback_READ_dgb addr="
             <<hex<<showbase<< address <<" size="<<dec<< trans.get_data_length() <<" data= 0x";
        for (int i=trans.get_data_length()-1; i>=0; i--)
            cout <<hex<<noshowbase<< (unsigned)trans.get_data_ptr()[i];
        cout <<endl;
      #endif

      return trans.get_data_length();
    #else
      cout <<name()<<" @ "<<sc_time_stamp()<<" ERROR: VIVY jpeg_dma_v2r_callback_READ_dbg() not enabled in SC_MODULE= 'vivy_jpeg_pv'"
           <<" use '#define ENABLE_jpeg_dma_v2r_DEBUG_SOCKET'"
           <<" addr="<<hex<<showbase<< address <<endl;
      return 0; 
    #endif 
} 

/////////////////////////////////////////////////////
// Write Debug callback for jpeg_dma_v2r 
///////////////////////////////////////////////////// 
unsigned vivy_jpeg_pv::jpeg_dma_v2r_callback_write_dbg(config::uint64 address, unsigned char* data, unsigned size) 
{ 
    // Call nb_transport_fw in UVM-Connect to mimic SystemC TLM Debug call.
    // SystemVerilog implementation of nb_transport_fw MUST terminate it early by specifying a return phase of "END_RESP"
    tlm::tlm_generic_payload trans;
    tlm::tlm_phase           phase = BEGIN_REQ;
    sc_time                  delay = SC_ZERO_TIME;

    trans.set_write();
    trans.set_address(address);
    trans.set_data_ptr(data);
    trans.set_data_length(size);
    trans.set_streaming_width(size);

    #ifdef ENABLE_jpeg_dma_v2r_DEBUG_SOCKET 

      #if (defined VIVY_DEBUG || 0)
        cout <<name()<<" @ "<<sc_time_stamp()<<" jpeg_dma_v2r_callback_WRITE_dgb addr="
             <<hex<<showbase<< address <<" size="<<dec<< trans.get_data_length() <<" data= 0x";
        for (int i=trans.get_data_length()-1; i>=0; i--)
            cout <<hex<<noshowbase<< (unsigned)trans.get_data_ptr()[i];
        cout <<endl;
      #endif
      (*jpeg_dma_v2r_debug_socket_to_uvmc)->nb_transport_fw(trans, phase, delay);

      return trans.get_data_length();
    #else
      cout <<name()<<" @ "<<sc_time_stamp()<<" ERROR: VIVY jpeg_dma_v2r_callback_WRITE_dbg() not enabled in SC_MODULE= 'vivy_jpeg_pv'"
           <<" use '#define ENABLE_jpeg_dma_v2r_DEBUG_SOCKET'"
           <<" addr="<<hex<<showbase<< address <<endl;
      return 0; 
    #endif 
}

bool vivy_jpeg_pv::jpeg_dma_v2r_get_direct_memory_ptr(config::uint64 address, tlm::tlm_dmi& dmiData) 
  { return false; }


