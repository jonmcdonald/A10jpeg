
/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file contains the PV class for vivy_stimulus.
//* This is a template file: You may modify this file to implement the 
//* behavior of your component. 
//* 
//* Model Builder version: 4.1.0
//* Generated on: Jan. 27, 2016 02:55:25 PM, (user: mbradley)
//*>


#include "vivy_stimulus_pv.h"
#include <iostream>
#include <string>

//#define VIVY_DEBUG


//constructor
vivy_stimulus_pv::vivy_stimulus_pv(sc_module_name module_name) 
  : vivy_stimulus_pv_base(module_name)
   ,jpeg_irq_r2v_fifo("jpeg_irq_r2v_fifo",-1)
{
    if (! vivy_disable) 
    {
        jpeg_regs_v2r_socket_to_uvmc = new  tlm_utils::simple_initiator_socket<vivy_stimulus_pv>("jpeg_regs_v2r_socket_to_uvmc"); 
        #ifdef ENABLE_jpeg_regs_v2r_DEBUG_SOCKET 
          jpeg_regs_v2r_debug_socket_to_uvmc = new  tlm_utils::simple_initiator_socket<vivy_stimulus_pv>("jpeg_regs_v2r_debug_socket_to_uvmc"); 
        #endif
        jpeg_dma_r2v_socket_from_uvmc = new  tlm_utils::simple_target_socket<vivy_stimulus_pv>("jpeg_dma_r2v_socket_from_uvmc");
        jpeg_irq_r2v_socket_from_uvmc = new  tlm_utils::simple_target_socket<vivy_stimulus_pv>("jpeg_irq_r2v_socket_from_uvmc");

        SC_THREAD(thread_jpeg_irq_r2v);

        // Bindings to UVM Connect (uvmcName must be unique)
        string uvmcName;
        string instName = name();
        instName.erase(instName.length()-2,2); 

        // use colon for running Vista in a separate process, as well as single process
        string uvmcColon_prefix = ":uvmc_"; 

        // store hierarchical port name in 'uvmcConnectNames' for printf
        // Also store uvmc connect string in 'uvmcConnectNames' for uvmc_connect call
        // Use default uvmc connect string, or value from parameters.txt

        uvmcConnectNames.push_back(string(instName + string("jpeg_regs_v2r")));
        if (*uvmc_jpeg_regs_v2r == 0) 
            uvmcName = uvmcColon_prefix + string("jpeg_regs_v2r");
        else 
            uvmcName = string(uvmc_jpeg_regs_v2r);
        uvmcConnectNames.push_back(uvmcName);  
        uvmc_connect <uvmc_xl_converter<tlm_generic_payload> > (*jpeg_regs_v2r_socket_to_uvmc, uvmcName);
        
        #ifdef ENABLE_jpeg_regs_v2r_DEBUG_SOCKET 
          uvmcConnectNames.push_back(string(instName + string("dbg_jpeg_regs_v2r")));
          if (*uvmc_dbg_jpeg_regs_v2r == 0) 
              uvmcName = uvmcColon_prefix + string("dbg_jpeg_regs_v2r");
          else 
              uvmcName = string(uvmc_dbg_jpeg_regs_v2r);
          uvmcConnectNames.push_back(uvmcName);  
          uvmc_connect <uvmc_xl_converter<tlm_generic_payload> > (*jpeg_regs_v2r_debug_socket_to_uvmc, uvmcName);
        #endif

        uvmcConnectNames.push_back(string(instName + string("jpeg_dma_r2v")));
        if (*uvmc_jpeg_dma_r2v == 0) 
            uvmcName = uvmcColon_prefix + string("jpeg_dma_r2v");
        else 
            uvmcName = string(uvmc_jpeg_dma_r2v);
        uvmcConnectNames.push_back(uvmcName);  
        uvmc_connect <uvmc_xl_converter<tlm_generic_payload> > (*jpeg_dma_r2v_socket_from_uvmc, uvmcName);

        uvmcConnectNames.push_back(string(instName + string("jpeg_irq_r2v")));
        if (*uvmc_jpeg_irq_r2v == 0) 
            uvmcName = uvmcColon_prefix + string("jpeg_irq_r2v");
        else 
            uvmcName = string(uvmc_jpeg_irq_r2v);
        uvmcConnectNames.push_back(uvmcName);  
        uvmc_connect <uvmc_xl_converter<tlm_generic_payload> > (*jpeg_irq_r2v_socket_from_uvmc, uvmcName); 

        // register simple_target_socket transport callbacks
        jpeg_dma_r2v_socket_from_uvmc->register_b_transport( this, &vivy_stimulus_pv::jpeg_dma_r2v_b_transport);
        jpeg_dma_r2v_socket_from_uvmc->register_nb_transport_fw( this, &vivy_stimulus_pv::jpeg_dma_r2v_nb_transport_fw);

        jpeg_irq_r2v_socket_from_uvmc->register_b_transport( this, &vivy_stimulus_pv::jpeg_irq_r2v_b_transport);
        jpeg_irq_r2v_socket_from_uvmc->register_nb_transport_fw( this, &vivy_stimulus_pv::jpeg_irq_r2v_nb_transport_fw);

        jpeg_regs_v2r_socket_to_uvmc->register_nb_transport_bw( this, &vivy_stimulus_pv::jpeg_regs_v2r_nb_transport_bw);

    
        for (vector<string>::iterator it=uvmcConnectNames.begin(); it != uvmcConnectNames.end(); it=it+2) 
            cout <<" VistaVerify UVM Connect path for pin '"<< *(it) <<"' => '"<< *(it+1) <<"'"<<endl;
    } 
}


  
  ////////////////////////////////////////////
  // Slave bus Transaction forwarded to UVMC
  //////////////////////////////////////////// 
  void vivy_stimulus_pv::jpeg_regs_v2r_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, sc_core::sc_time& t) 
  {
    if (trans.get_data_length() == 0) {
        cout <<name()<<" @ "<<sc_time_stamp()<<" jpeg_regs_v2r_callback: Ignoring 0 length transaction "
             <<" addr="<<hex<<showbase<< trans.get_address() <<" streaming_width="<<dec<< trans.get_streaming_width()
             <<" data_length="<< trans.get_data_length() <<" is_write="<< trans.is_write() <<endl;
        return;
    }

    (*jpeg_regs_v2r_socket_to_uvmc)->b_transport(trans, t);

    #if (defined VIVY_DEBUG || 0)
    if (trans.is_write())
        cout <<name()<<" @ "<<sc_time_stamp()<<" jpeg_regs_v2r_callback: WRITE addr="<<hex<<showbase<< trans.get_address() 
                     <<" data[3:0]="<< *(unsigned int *)trans.get_data_ptr() <<" size="<<dec<< trans.get_data_length() <<endl;
    else
        cout <<name()<<" @ "<<sc_time_stamp()<<" jpeg_regs_v2r_callback: READ  addr="<<hex<<showbase<< trans.get_address() 
                     <<" data[3:0]="<< *(unsigned int *)trans.get_data_ptr() <<" size="<<dec<< trans.get_data_length() <<endl;
    #endif

    if (trans.get_response_status() == tlm::TLM_INCOMPLETE_RESPONSE)
        trans.set_response_status(TLM_OK_RESPONSE);  // Not sure if this needed...
  } 

  tlm::tlm_sync_enum vivy_stimulus_pv::jpeg_regs_v2r_nb_transport_bw(tlm::tlm_generic_payload& trans, tlm::tlm_phase& phase, sc_core::sc_time& delay) 
  { 
    cout <<name()<<" @ "<<sc_time_stamp()<<" WARNING: Hello from jpeg_regs_v2r_nb_transport_bw() currently does nothing...\n";
    phase = END_RESP;
    trans.set_response_status(TLM_COMMAND_ERROR_RESPONSE);
    return(TLM_COMPLETED);
  }  

  //////////////////////////////////////////////////
  // Master bus Transaction from UVMC
  ////////////////////////////////////////////////// 
  void vivy_stimulus_pv::jpeg_dma_r2v_b_transport(tlm::tlm_generic_payload& trans, sc_core::sc_time& delay)
  {
    jpeg_dma_r2v_transport(trans);

    #if (defined VIVY_DEBUG || 0)
    if (trans.is_write())
        cout <<name()<<" @ "<<sc_time_stamp()<<" jpeg_dma_r2v_b_transport: WRITE addr="<<hex<<showbase<< trans.get_address() 
                     <<" data[3:0]="<< *(unsigned int *)trans.get_data_ptr() <<" size="<<dec<< trans.get_data_length() <<endl;
    else
        cout <<name()<<" @ "<<sc_time_stamp()<<" jpeg_dma_r2v_b_transport: READ  addr="<<hex<<showbase<< trans.get_address() 
                     <<" data[3:0]="<< *(unsigned int *)trans.get_data_ptr() <<" size="<<dec<< trans.get_data_length() <<endl;
    #endif

    trans.set_response_status(TLM_OK_RESPONSE);
  } 
  
  tlm::tlm_sync_enum vivy_stimulus_pv::jpeg_dma_r2v_nb_transport_fw(tlm::tlm_generic_payload& trans, tlm::tlm_phase& phase, sc_core::sc_time& delay)
  {
    cout <<name()<<" @ "<<sc_time_stamp()<<" WARNING: Hello from jpeg_dma_r2v_nb_transport_fw() is NOT yet implemented...\n";
    #if (defined VIVY_DEBUG || 0)
    if (trans.is_write())
        cout <<name()<<" @ "<<sc_time_stamp()<<" jpeg_dma_r2v_nb_transport_fw: WRITE addr="<<hex<<showbase<< trans.get_address() 
                     <<" data[3:0]="<< *(unsigned int *)trans.get_data_ptr() <<" size="<<dec<< trans.get_data_length() <<endl;
    else
        cout <<name()<<" @ "<<sc_time_stamp()<<" jpeg_dma_r2v_nb_transport_fw: READ  addr="<<hex<<showbase<< trans.get_address() 
                     <<" data[3:0]="<< *(unsigned int *)trans.get_data_ptr() <<" size="<<dec<< trans.get_data_length() <<endl;
    #endif
    trans.set_response_status(TLM_COMMAND_ERROR_RESPONSE);
    return(TLM_COMPLETED);
  } 

  /////////////////////////////////////////////////
  // Callbacks from UVM Connect to Vista signal out
  ///////////////////////////////////////////////// 
  tlm::tlm_sync_enum vivy_stimulus_pv::jpeg_irq_r2v_nb_transport_fw(tlm::tlm_generic_payload& trans, tlm::tlm_phase& phase, sc_core::sc_time& delay)
  {
    unsigned long long SigOutData = 0;
    unsigned           size       = trans.get_data_length();

    if (size>sizeof(SigOutData)) {
        cout <<name()<<" @ "<<sc_time_stamp()<<" ERROR jpeg_irq_r2v_nb_transport_fw(): incoming data size truncated to 64 bits \n";
        size = sizeof(SigOutData);
    } 
    memcpy(&SigOutData, trans.get_data_ptr(), size);
    #if (defined VIVY_DEBUG || 0)
        cout <<name()<<" @ "<<sc_time_stamp()<<" jpeg_irq_r2v_nb_transport_fw: WRITE data="<< SigOutData <<endl;
    #endif

    // use of XlTLMConduit requires non-blocking return, use tlm_fifo and SC_THREAD to accomplish this.
    assert (jpeg_irq_r2v_fifo.nb_put(SigOutData) == true);

    phase = END_RESP;
    trans.set_response_status(TLM_OK_RESPONSE);
    return(TLM_COMPLETED);
  } 
  //
  // Thread to drive jpeg_irq_r2v 
  void vivy_stimulus_pv::thread_jpeg_irq_r2v() 
  {
    unsigned long long sigOutData;
    while (1) {
      sigOutData = jpeg_irq_r2v_fifo.get();
      #if (defined VIVY_DEBUG || 0)
        cout <<name()<<" @ "<<sc_time_stamp()<<" thread_jpeg_irq_r2v: WRITE data="<< sigOutData <<endl;
      #endif
      jpeg_irq_r2v.write(sigOutData);
    }
  } 
  // optional b_transport for jpeg_irq_r2v 
  void vivy_stimulus_pv::jpeg_irq_r2v_b_transport(tlm::tlm_generic_payload& trans, sc_core::sc_time& delay) 
  {
    unsigned long long data = 0;
    unsigned           size = trans.get_data_length();
    if (size>sizeof(data)) {
        cout <<name()<<" @ "<<sc_time_stamp()<<" ERROR jpeg_irq_r2v_b_transport(): incoming data size truncated to 64 bits \n";
        size = sizeof(data);
    } 
    memcpy(&data, trans.get_data_ptr(), size);
    #if (defined VIVY_DEBUG || 0)
        cout <<name()<<" @ "<<sc_time_stamp()<<" jpeg_irq_r2v_b_transport: WRITE data="<< data <<endl;
    #endif
    jpeg_irq_r2v.write(data);
  } 

    

/////////////////////////////////////////////////////
// Read Debug callback for jpeg_regs_v2r 
///////////////////////////////////////////////////// 
unsigned vivy_stimulus_pv::jpeg_regs_v2r_callback_read_dbg(config::uint64 address, unsigned char* data, unsigned size) 
{ 
    // Call nb_transport_fw in UVM-Connect to mimic SystemC TLM Debug call.
    // SystemVerilog implementation of nb_transport_fw should terminate it early by specifying a return phase of "END_RESP"
    tlm::tlm_generic_payload trans;
    tlm::tlm_phase           phase = BEGIN_REQ;
    sc_time                  delay = SC_ZERO_TIME;

    trans.set_read();
    trans.set_address(address);
    trans.set_data_ptr(data);
    trans.set_data_length(size);
    trans.set_streaming_width(size);

    #ifdef ENABLE_jpeg_regs_v2r_DEBUG_SOCKET 
      (*jpeg_regs_v2r_debug_socket_to_uvmc)->nb_transport_fw(trans, phase, delay);

      #if (defined VIVY_DEBUG || 0)
        cout <<name()<<" @ "<<sc_time_stamp()<<" jpeg_regs_v2r_callback_READ_dgb addr="
             <<hex<<showbase<< address <<" size="<<dec<< trans.get_data_length() <<" data= 0x";
        for (int i=trans.get_data_length()-1; i>=0; i--)
            cout <<hex<<noshowbase<< (unsigned)trans.get_data_ptr()[i];
        cout <<endl;
      #endif

      return trans.get_data_length();
    #else
      cout <<name()<<" @ "<<sc_time_stamp()<<" ERROR: VIVY jpeg_regs_v2r_callback_READ_dbg() not enabled in SC_MODULE= 'vivy_stimulus_pv'"
           <<" use '#define ENABLE_jpeg_regs_v2r_DEBUG_SOCKET'"
           <<" addr="<<hex<<showbase<< address <<endl;
      return 0; 
    #endif 
} 

/////////////////////////////////////////////////////
// Write Debug callback for jpeg_regs_v2r 
///////////////////////////////////////////////////// 
unsigned vivy_stimulus_pv::jpeg_regs_v2r_callback_write_dbg(config::uint64 address, unsigned char* data, unsigned size) 
{ 
    // Call nb_transport_fw in UVM-Connect to mimic SystemC TLM Debug call.
    // SystemVerilog implementation of nb_transport_fw MUST terminate it early by specifying a return phase of "END_RESP"
    tlm::tlm_generic_payload trans;
    tlm::tlm_phase           phase = BEGIN_REQ;
    sc_time                  delay = SC_ZERO_TIME;

    trans.set_write();
    trans.set_address(address);
    trans.set_data_ptr(data);
    trans.set_data_length(size);
    trans.set_streaming_width(size);

    #ifdef ENABLE_jpeg_regs_v2r_DEBUG_SOCKET 

      #if (defined VIVY_DEBUG || 0)
        cout <<name()<<" @ "<<sc_time_stamp()<<" jpeg_regs_v2r_callback_WRITE_dgb addr="
             <<hex<<showbase<< address <<" size="<<dec<< trans.get_data_length() <<" data= 0x";
        for (int i=trans.get_data_length()-1; i>=0; i--)
            cout <<hex<<noshowbase<< (unsigned)trans.get_data_ptr()[i];
        cout <<endl;
      #endif
      (*jpeg_regs_v2r_debug_socket_to_uvmc)->nb_transport_fw(trans, phase, delay);

      return trans.get_data_length();
    #else
      cout <<name()<<" @ "<<sc_time_stamp()<<" ERROR: VIVY jpeg_regs_v2r_callback_WRITE_dbg() not enabled in SC_MODULE= 'vivy_stimulus_pv'"
           <<" use '#define ENABLE_jpeg_regs_v2r_DEBUG_SOCKET'"
           <<" addr="<<hex<<showbase<< address <<endl;
      return 0; 
    #endif 
}

bool vivy_stimulus_pv::jpeg_regs_v2r_get_direct_memory_ptr(config::uint64 address, tlm::tlm_dmi& dmiData) 
  { return false; }


