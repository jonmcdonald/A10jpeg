
/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file contains the PV class for JPEG_ENCODER.
//* This is a template file: You may modify this file to implement the 
//* behavior of your component. 
//* 
//* Model Builder version: 4.1.0
//* Generated on: Jan. 27, 2016 06:22:45 PM, (user: mbradley)
//*>



#include "JPEG_ENCODER_pv.h"
#include <iostream>


using namespace sc_core;
using namespace sc_dt;
using namespace std;

//constructor
JPEG_ENCODER_pv::JPEG_ENCODER_pv(sc_module_name module_name) 
  : JPEG_ENCODER_pv_base(module_name) 
   ,mbFifo(1)
   ,jpegRunning(0)
   ,fp("jpeg_out.jpg")

{
    SC_THREAD(thread);
    // Construct a Jpeg output object

} 

// Read callback for status register.
// The value that this function returns, will be returned to the initiator port that requested its value.
unsigned int JPEG_ENCODER_pv::cb_read_status() {
    unsigned tmp;
    tmp = status = (irq.read() << 1) | jpegRunning;
    return tmp; // status register may not be yet updated
}
 
// Read callback for start register.
// The value that this function returns, will be returned to the initiator port that requested its value.
unsigned int JPEG_ENCODER_pv::cb_read_start() {
  return start;
}
  
// Write callback for start register.
// The newValue has been already assigned to the start register.
void JPEG_ENCODER_pv::cb_write_start(unsigned int newValue) {
    if ((start &1) == 1) {
        cout <<name()<<" @ "<<sc_time_stamp()<<" JPEG start bit written"<<endl;
        mbFifo.put(1);
    }
    else if ((start &1) == 0) {
        irq.write(0);
    }
}

void JPEG_ENCODER_pv::thread()
{
    unsigned numBlocks;
    unsigned outputCount;
    unsigned dmaWriteSize;

    while (1) {
        mbFifo.peek(); // block/wait until start bit is written

        cout <<name()<<" @ "<<sc_time_stamp()<<" Starting JPEG compression"<<endl;
        outputlength    = 0;
        outputCount     = 0;
        jpegRunning     = 1;
        imageReadIndex  = 0;
        imageWriteIndex = outputaddr;
        width           = (input_w_h_size >> 13) & 0x3FFF; // 14 bits
        height          = input_w_h_size & 0x1FFF;         // 13 bits
        numBlocks       = (width*height+BLOCK_SIZE-1) / BLOCK_SIZE;
        cout << " input_w_h_size= "<<hex<< input_w_h_size <<" width= "<<dec<< width <<" height= "<< height <<endl;

        // write out all the header info for the jpeg
        cout <<" write preamble width= "<< width <<" height= "<< height <<endl;
        fp.writepreamble(height, width);
        
        cout <<" jpegResult Size after preamble = "<<dec<< fp.get_resultSize() <<endl;
        if (fp.get_resultSize() >= WRITE_BLOCK_SIZE) {
            // have enough data for DMA write burst
            for (int i=0; i<WRITE_BLOCK_SIZE; i++) {
                imageWriteData[i] = fp.get_resultByte();
                printf(" %02X",imageWriteData[i]);
            }

            master_write(imageWriteIndex , imageWriteData, WRITE_BLOCK_SIZE);
            cout <<" preamble dma burst imageWriteIndex = "<<hex<< imageWriteIndex <<endl;
            imageWriteIndex += WRITE_BLOCK_SIZE;
        }

        if (numBlocks != width*height/BLOCK_SIZE)
            cout <<name()<<" @ "<<sc_time_stamp()<<" ERROR: bmp width*height not a multiple of BLOCK_SIZE ("<< BLOCK_SIZE <<")"<<endl;

        for (unsigned block=0; block<numBlocks; block++)
        {
            //cout <<name()<<" @ "<<sc_time_stamp()<<" processing block "<<dec<< block <<endl;
            master_read(inputaddr+imageReadIndex, (char *)imageReadData, BLOCK_SIZE*4);
            imageReadIndex += BLOCK_SIZE*4; // 4 bytes for each rgb pixel in the block

            for (int i=0; i<64; i++) {
                rgb[i].r = (imageReadData[i] >> 16) & 0xFF;
                rgb[i].g = (imageReadData[i] >>  8) & 0xFF;
                rgb[i].b = (imageReadData[i] >>  0) & 0xFF;
                //printf(",0x00%02X%02X%02X\n",(unsigned)rgb[i].r, (unsigned)rgb[i].g, (unsigned)rgb[i].b);
            }

            // process Y, Cb and Cr blocks, one after the other
            for (int type = 0; type <= 2; type++) 
            {

                blocktype.write(type);
                for (int i=0; i<64; i++) 
                    rgbstream.write(rgb[i]);
            
                pixelpipe(blocktype, rgbstream, hufstream);  // The JPEG algorithm

                for (int i=0; i<64; i++) 
                    codes[i] = hufstream.read();
            
                // write out the bitstream
                for (int k=0; k<64; k++) {
                    fp.write(codes[k].size, codes[k].code);
                }
            }
            if (fp.get_resultSize() >= WRITE_BLOCK_SIZE) {
                // have enough data for DMA write burst
                for (int i=0; i<WRITE_BLOCK_SIZE; i++)
                    imageWriteData[i] = fp.get_resultByte();

                cout <<" dma burst imageWriteIndex = "<<hex<< imageWriteIndex <<endl;
                master_write(imageWriteIndex , imageWriteData, WRITE_BLOCK_SIZE);
                imageWriteIndex += WRITE_BLOCK_SIZE;
            }
        }
        // write out trailing info for the jpeg
        fp.writepostscript();

        // DMA remaining bytes
        dmaWriteSize = fp.get_resultSize();
        cout <<" last burst dmaWriteSize = "<<dec<< dmaWriteSize <<endl;
        cout <<" dma burst imageWriteIndex = "<<hex<< imageWriteIndex <<endl;
        if (dmaWriteSize > 0) {
            for (unsigned i=0; i<dmaWriteSize; i++)
                imageWriteData[i] = fp.get_resultByte();
            master_write(imageWriteIndex , imageWriteData, dmaWriteSize);
        }
        
        jpegRunning   = 0;
        outputlength  = fp.get_outputlength();
        printf("outputlength = %d\n",fp.get_outputlength());
        irq.write(1);
        
        mbFifo.get();  // release Fifo, Done.
    }
}
    
//============================================== 
// Read callback for slave port.
// Returns true when successful.
bool JPEG_ENCODER_pv::slave_callback_read(mb_address_type address, unsigned char* data, unsigned size) {
  return true;
}
// Write callback for slave port.
// Returns true when successful.
bool JPEG_ENCODER_pv::slave_callback_write(mb_address_type address, unsigned char* data, unsigned size) {
  return true;
} 
unsigned JPEG_ENCODER_pv::slave_callback_read_dbg(mb_address_type address, unsigned char* data, unsigned size) {
  return 0;
} 
unsigned JPEG_ENCODER_pv::slave_callback_write_dbg(mb_address_type address, unsigned char* data, unsigned size) {
  return 0;
} 
bool JPEG_ENCODER_pv::slave_get_direct_memory_ptr(mb_address_type address, tlm::tlm_dmi& dmiData) {
  return false;
}
void JPEG_ENCODER_pv::cb_transport_dbg_status(tlm::tlm_generic_payload& trans) {}
void JPEG_ENCODER_pv::cb_transport_dbg_start(tlm::tlm_generic_payload& trans) {}
