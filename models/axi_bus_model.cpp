
/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file is write protected. 
//* DO NOT MODIFY THIS FILE.
//*
//* This file is generated according to the parameters in the 
//* Model Builder form.
//* This class contains the infrastructure to define the behavior of the component.
//* The axi_bus_pv will be derived from this class.
//*
//* Model Builder version: 4.1.0
//* Generated on: Jan. 27, 2016 03:08:49 PM, (user: mbradley)
//*>


#include "axi_bus_model.h"

#ifdef MODEL_BUILDER_VERSION_NUMBER
#if 4100 != MODEL_BUILDER_VERSION_NUMBER
#error "This model was generated using Model Builder version: 4.1.0. Please regenerate model."
#endif
#else
#error "Please regenerate model."
#endif

using namespace sc_core;
using namespace sc_dt;
using namespace std;


axi_bus_pv_base::axi_bus_pv_base(sc_module_name& module_name) : 
  axi_bus_pv_base_mb_compatibility(module_name),
  axi_bus_pv_base_parameters(this),
  VISTA_MB_PV_INIT_MEMBER(sram_master),
  VISTA_MB_PV_INIT_MEMBER(jpeg_regs),
  VISTA_MB_PV_INIT_MEMBER(driver),
  VISTA_MB_PV_INIT_MEMBER(jpeg_dma) {


  payload_on_stack = 0;
  payload_for_token = 0;

  VISTA_MB_PV_BIND_FW_PROCESS_TO_TARGET(driver);
  VISTA_MB_PV_BIND_FW_PROCESS_TO_TARGET(jpeg_dma);
  VISTA_MB_PV_BIND_BW_PROCESS_TO_MASTER(sram_master);
  VISTA_MB_PV_BIND_BW_PROCESS_TO_MASTER(jpeg_regs);
  VISTA_MB_PV_REGISTER_SELF_FW_PROCESS_CALLBACKS(driver);
  VISTA_MB_PV_REGISTER_SELF_FW_PROCESS_CALLBACKS(jpeg_dma);
  VISTA_MB_PV_REGISTER_SELF_BW_PROCESS_CALLBACKS(sram_master);
  VISTA_MB_PV_REGISTER_SELF_BW_PROCESS_CALLBACKS(jpeg_regs);

}

void axi_bus_pv_base::reset_model() {
  // reset all registers


  
  // reset value for output signals

  // reset value for input signals

}

axi_bus_pv_base_parameters::axi_bus_pv_base_parameters(sc_object* object) :
  m_object(object),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, clock, sc_core::sc_time(10, sc_core::SC_NS)),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, axi_clock, clock),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, nominal_voltage, 1),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, verbose_parameters, true),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, dmi_enabled, true),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, warning_level, "WARNING"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, layers, ""),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, slave_sets, ""),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, write_broadcast, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, driver_priority, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, driver_vmap, ""),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, sram_master_priority, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, sram_master_base_address, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, sram_master_size, 0x20000000),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, sram_master_subtract_base_address, 1),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, sram_master_secure, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, sram_master_additional_ranges, ""),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, sram_master_latency, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, jpeg_dma_priority, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, jpeg_dma_vmap, ""),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, jpeg_regs_priority, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, jpeg_regs_base_address, 0xE0000000),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, jpeg_regs_size, 0x100),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, jpeg_regs_subtract_base_address, 1),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, jpeg_regs_secure, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, jpeg_regs_additional_ranges, ""),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, jpeg_regs_latency, 0)
{
  if(verbose_parameters) print_parameters();
}

void axi_bus_pv_base_parameters::print_parameters()
{
  const char* name;
  if (!strcmp(m_object->basename(), "PV"))
    name = m_object->get_parent()->name();
  else
    name = m_object->name();

  std::cout.setf(ios::hex, ios::basefield);
  std::cout.setf(ios::showbase);
  std::cout << name << "::parameters:\n";
  std::cout << "\tclock = " << clock << "\n";
  std::cout << "\taxi_clock = " << axi_clock << "\n";
  std::cout << "\tnominal_voltage = " << nominal_voltage << "\n";
  std::cout << "\tverbose_parameters = " << verbose_parameters << "\n";
  std::cout << "\tdmi_enabled = " << dmi_enabled << "\n";
  std::cout << "\twarning_level = " << warning_level << "\n";
  std::cout << "\tlayers = " << layers << "\n";
  std::cout << "\tslave_sets = " << slave_sets << "\n";
  std::cout << "\twrite_broadcast = " << write_broadcast << "\n";
  std::cout << "\tdriver_priority = " << driver_priority << "\n";
  std::cout << "\tdriver_vmap = " << driver_vmap << "\n";
  std::cout << "\tsram_master_priority = " << sram_master_priority << "\n";
  std::cout << "\tsram_master_base_address = " << sram_master_base_address << "\n";
  std::cout << "\tsram_master_size = " << sram_master_size << "\n";
  std::cout << "\tsram_master_subtract_base_address = " << sram_master_subtract_base_address << "\n";
  std::cout << "\tsram_master_secure = " << sram_master_secure << "\n";
  std::cout << "\tsram_master_additional_ranges = " << sram_master_additional_ranges << "\n";
  std::cout << "\tsram_master_latency = " << sram_master_latency << "\n";
  std::cout << "\tjpeg_dma_priority = " << jpeg_dma_priority << "\n";
  std::cout << "\tjpeg_dma_vmap = " << jpeg_dma_vmap << "\n";
  std::cout << "\tjpeg_regs_priority = " << jpeg_regs_priority << "\n";
  std::cout << "\tjpeg_regs_base_address = " << jpeg_regs_base_address << "\n";
  std::cout << "\tjpeg_regs_size = " << jpeg_regs_size << "\n";
  std::cout << "\tjpeg_regs_subtract_base_address = " << jpeg_regs_subtract_base_address << "\n";
  std::cout << "\tjpeg_regs_secure = " << jpeg_regs_secure << "\n";
  std::cout << "\tjpeg_regs_additional_ranges = " << jpeg_regs_additional_ranges << "\n";
  std::cout << "\tjpeg_regs_latency = " << jpeg_regs_latency << "\n";
  std::cout.unsetf(ios::showbase);
  std::cout.setf(ios::dec, ios::basefield);
  std::cout << std::endl;
}



/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/


#include <iostream>





axi_bus_base1_pv::axi_bus_base1_pv(sc_module_name module_name) :
  axi_bus_pv_base(module_name) {
  dbg_port.bind(m_dbg_port_fw_process);
  m_dbg_port_fw_process.register_b_transport(this, &axi_bus_base1_pv::dbg_port_callback);
  m_dbg_port_fw_process.register_transport_dbg(this, &axi_bus_base1_pv::dbg_port_callback_dbg);
  m_dbg_port_fw_process.register_get_direct_mem_ptr(this, &axi_bus_base1_pv::dbg_port_get_direct_memory_ptr_callback);

  m_model = dynamic_cast<PapoulisBusBaseModel *>(getSystemCBaseModel());
  if (m_model) {
    decoder = m_model->get_decoder();
 
  } else {
    decoder = new esl::sc_sim::user_model::Decoder(2, 4, write_broadcast);
    decoder->registerSlavePort(1, this->sram_master_base_address, this->sram_master_size, this->sram_master_subtract_base_address);
    decoder->registerSlavePort(3, this->jpeg_regs_base_address, this->jpeg_regs_size, this->jpeg_regs_subtract_base_address);
    decoder->parseVmapString(0, this->driver_vmap, "driver_vmap");
    decoder->parseVmapString(2, this->jpeg_dma_vmap, "jpeg_dma_vmap");
  }
  
  m_port_count = 4;
  m_layers_count = m_model->get_arbiter()->get_layers_count();
  m_is_multi_channel = 1;
  m_bus_scheduler = new esl::sc_sim::BusScheduler(m_port_count, m_layers_count, m_is_multi_channel);
  m_apply_policies = false;
  const char* policy_modeling = "lt_policy_modeling";
  
  mb::sysc::add_parameter_listener(this->name(), policy_modeling, this);
  if (mb::sysc::sdParameterExists(policy_modeling)) {
    if (!strcasecmp(mb::sysc::sdGetParameterAsConstString(policy_modeling), "dynamic")) {
      m_apply_policies = true;
    }
  }
}

axi_bus_base1_pv::~axi_bus_base1_pv()
{
  delete m_bus_scheduler;
}
void axi_bus_base1_pv::parameter_changed(const std::string& old_value,
                                             const std::string& new_value) {
  if (!strcasecmp(new_value.c_str(), "dynamic")) {
    m_apply_policies = true;
  }
  else {
    m_apply_policies = false;
  }
}



void axi_bus_base1_pv::driver_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, sc_core::sc_time& t) {
  routePayload(trans, 0, false, t);
  
}

unsigned axi_bus_base1_pv::driver_callback_dbg(tlm::tlm_base_protocol_types::tlm_payload_type& trans) {

  sc_core::sc_time t = sc_core::SC_ZERO_TIME;
  return routePayload(trans, 0, true, t);

}

bool axi_bus_base1_pv::driver_get_direct_memory_ptr_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, tlm::tlm_dmi& dmiData) {

  mb::tlm20::MemoryMap::DiscoveryExt* discovery_ext =
    trans.get_extension<mb::tlm20::MemoryMap::DiscoveryExt>();
  if (mb_unlikely(discovery_ext != 0)) {
    sc_dt::uint64 offset;
    sc_dt::uint64 base = discovery_ext->get_base_address(trans);
    if (this->sram_master_subtract_base_address) {
      offset = this->sram_master_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->sram_master_size);
    if (this->jpeg_regs_subtract_base_address) {
      offset = this->jpeg_regs_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->jpeg_regs_size);
  }

   sc_dt::uint64 virtualAddress = decoder->getVirtualAddress(0, trans.get_address());
   std::vector<long> slavePortIndexArray;
   esl::sc_sim::secure_payload* secure_inst = decoder->getSecurePayload();
   if (secure_inst) {
     if (secure_inst->get_security_value(trans) ==
         esl::sc_sim::secure_payload::NON_SECURE)
       decoder->getNonSecuredSlavePortIndexArray(slavePortIndexArray, virtualAddress, trans.get_data_length() == 0 ? 1 : trans.get_data_length(), name(), get_port_name(0), 0, true);
     else
       decoder->getSecuredSlavePortIndexArray(slavePortIndexArray, virtualAddress, trans.get_data_length() == 0 ? 1 : trans.get_data_length(), name(), get_port_name(0), 0, true);
    } else
     decoder->getSlavePortIndexArray(slavePortIndexArray, virtualAddress, trans.get_data_length() == 0 ? 1 : trans.get_data_length(), name(), get_port_name(0), true);
   if (slavePortIndexArray.size() == 0 || 
       (write_broadcast && trans.is_write())) {
    dmiData.set_start_address(trans.get_address());
    dmiData.set_end_address(trans.get_address());
    return false;
  }
   
   long slavePortIndex = slavePortIndexArray[0];
  if (mb_unlikely(discovery_ext != 0)) {
    sc_dt::uint64 base = discovery_ext->get_base_address(trans);
    config::uint64 startAddress, endAddress; bool subtractBaseAddress;
    decoder->getSlaveRange(slavePortIndex, startAddress, endAddress, subtractBaseAddress);
    discovery_ext->set_current_range(base + startAddress, base + endAddress);
  }

  sc_dt::uint64 baseAddress = decoder->getBaseAddress(slavePortIndex, virtualAddress);
  sc_dt::uint64 address = trans.get_address();
  trans.set_address(baseAddress);
  bool returnStatus = get_fw_transport_if(slavePortIndex)->get_direct_mem_ptr(trans, dmiData);
  trans.set_address(address);

  // clip the range
  sc_dt::uint64 dmiStartAddress = dmiData.get_start_address();
  sc_dt::uint64 dmiEndAddress = dmiData.get_end_address();
  unsigned char* dmiPtr = dmiData.get_dmi_ptr();
  signed long long offset = address - virtualAddress;
  clip_the_range(address, dmiStartAddress, dmiEndAddress, dmiPtr, slavePortIndex, offset);

  dmiData.set_start_address(dmiStartAddress);
  dmiData.set_end_address(dmiEndAddress);
  dmiData.set_dmi_ptr(dmiPtr);

  if (returnStatus) {
    if (secure_inst) {
      if (secure_inst->get_security_value(trans) ==
          esl::sc_sim::secure_payload::NON_SECURE &&
          decoder->getSecure(slavePortIndex, 0)) {
        trans.set_response_status(tlm::TLM_ADDRESS_ERROR_RESPONSE);
        returnStatus = false;
        dmiData.set_dmi_ptr(0);
        mb::tlm20::iss_core_ext *ext;
        trans.get_extension(ext);
        if(ext)
          ext->set_data_ptr(0);
        mb::tlm20::direct_call_ext *p_direct_call_ext = NULL;
        trans.get_extension(p_direct_call_ext);
        if (p_direct_call_ext)
          p_direct_call_ext->set_direct_call_if(0);
      }
    }
  }
  return returnStatus;
}


void axi_bus_base1_pv::jpeg_dma_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, sc_core::sc_time& t) {
  routePayload(trans, 2, false, t);
  
}

unsigned axi_bus_base1_pv::jpeg_dma_callback_dbg(tlm::tlm_base_protocol_types::tlm_payload_type& trans) {

  sc_core::sc_time t = sc_core::SC_ZERO_TIME;
  return routePayload(trans, 2, true, t);

}

bool axi_bus_base1_pv::jpeg_dma_get_direct_memory_ptr_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, tlm::tlm_dmi& dmiData) {

  mb::tlm20::MemoryMap::DiscoveryExt* discovery_ext =
    trans.get_extension<mb::tlm20::MemoryMap::DiscoveryExt>();
  if (mb_unlikely(discovery_ext != 0)) {
    sc_dt::uint64 offset;
    sc_dt::uint64 base = discovery_ext->get_base_address(trans);
    if (this->sram_master_subtract_base_address) {
      offset = this->sram_master_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->sram_master_size);
    if (this->jpeg_regs_subtract_base_address) {
      offset = this->jpeg_regs_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->jpeg_regs_size);
  }

   sc_dt::uint64 virtualAddress = decoder->getVirtualAddress(2, trans.get_address());
   std::vector<long> slavePortIndexArray;
   esl::sc_sim::secure_payload* secure_inst = decoder->getSecurePayload();
   if (secure_inst) {
     if (secure_inst->get_security_value(trans) ==
         esl::sc_sim::secure_payload::NON_SECURE)
       decoder->getNonSecuredSlavePortIndexArray(slavePortIndexArray, virtualAddress, trans.get_data_length() == 0 ? 1 : trans.get_data_length(), name(), get_port_name(2), 2, true);
     else
       decoder->getSecuredSlavePortIndexArray(slavePortIndexArray, virtualAddress, trans.get_data_length() == 0 ? 1 : trans.get_data_length(), name(), get_port_name(2), 2, true);
    } else
     decoder->getSlavePortIndexArray(slavePortIndexArray, virtualAddress, trans.get_data_length() == 0 ? 1 : trans.get_data_length(), name(), get_port_name(2), true);
   if (slavePortIndexArray.size() == 0 || 
       (write_broadcast && trans.is_write())) {
    dmiData.set_start_address(trans.get_address());
    dmiData.set_end_address(trans.get_address());
    return false;
  }
   
   long slavePortIndex = slavePortIndexArray[0];
  if (mb_unlikely(discovery_ext != 0)) {
    sc_dt::uint64 base = discovery_ext->get_base_address(trans);
    config::uint64 startAddress, endAddress; bool subtractBaseAddress;
    decoder->getSlaveRange(slavePortIndex, startAddress, endAddress, subtractBaseAddress);
    discovery_ext->set_current_range(base + startAddress, base + endAddress);
  }

  sc_dt::uint64 baseAddress = decoder->getBaseAddress(slavePortIndex, virtualAddress);
  sc_dt::uint64 address = trans.get_address();
  trans.set_address(baseAddress);
  bool returnStatus = get_fw_transport_if(slavePortIndex)->get_direct_mem_ptr(trans, dmiData);
  trans.set_address(address);

  // clip the range
  sc_dt::uint64 dmiStartAddress = dmiData.get_start_address();
  sc_dt::uint64 dmiEndAddress = dmiData.get_end_address();
  unsigned char* dmiPtr = dmiData.get_dmi_ptr();
  signed long long offset = address - virtualAddress;
  clip_the_range(address, dmiStartAddress, dmiEndAddress, dmiPtr, slavePortIndex, offset);

  dmiData.set_start_address(dmiStartAddress);
  dmiData.set_end_address(dmiEndAddress);
  dmiData.set_dmi_ptr(dmiPtr);

  if (returnStatus) {
    if (secure_inst) {
      if (secure_inst->get_security_value(trans) ==
          esl::sc_sim::secure_payload::NON_SECURE &&
          decoder->getSecure(slavePortIndex, 2)) {
        trans.set_response_status(tlm::TLM_ADDRESS_ERROR_RESPONSE);
        returnStatus = false;
        dmiData.set_dmi_ptr(0);
        mb::tlm20::iss_core_ext *ext;
        trans.get_extension(ext);
        if(ext)
          ext->set_data_ptr(0);
        mb::tlm20::direct_call_ext *p_direct_call_ext = NULL;
        trans.get_extension(p_direct_call_ext);
        if (p_direct_call_ext)
          p_direct_call_ext->set_direct_call_if(0);
      }
    }
  }
  return returnStatus;
}


void axi_bus_base1_pv::dbg_port_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, sc_core::sc_time& t) {
  routePayload(trans, (unsigned) (-1), false, t);
}

unsigned axi_bus_base1_pv::dbg_port_callback_dbg(tlm::tlm_base_protocol_types::tlm_payload_type& trans) {
  sc_core::sc_time t = sc_core::SC_ZERO_TIME;
  return routePayload(trans, (unsigned) (-1), true, t);
}

bool axi_bus_base1_pv::dbg_port_get_direct_memory_ptr_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, tlm::tlm_dmi& dmiData) {
  sc_dt::uint64 virtualAddress = trans.get_address();
  std::vector<long> slavePortIndexArray;
  decoder->getSlavePortIndexArray(slavePortIndexArray, virtualAddress, 32, name(), "dbg_port");
  if (slavePortIndexArray.size() == 0) {
    dmiData.set_start_address(trans.get_address());
    dmiData.set_end_address(trans.get_address());
    return false;
  }
   
  long slavePortIndex = slavePortIndexArray[0];
  

  sc_dt::uint64 baseAddress = decoder->getBaseAddress(slavePortIndex, virtualAddress);
  sc_dt::uint64 address = trans.get_address();
  trans.set_address(baseAddress);
  bool returnStatus = get_fw_transport_if(slavePortIndex)->get_direct_mem_ptr(trans, dmiData);
  trans.set_address(address);

  // clip the range
  sc_dt::uint64 dmiStartAddress = dmiData.get_start_address();
  sc_dt::uint64 dmiEndAddress = dmiData.get_end_address();
  unsigned char* dmiPtr = dmiData.get_dmi_ptr();
  signed long long offset = address - virtualAddress;
  clip_the_range(address, dmiStartAddress, dmiEndAddress, dmiPtr, slavePortIndex, offset);
  
  dmiData.set_start_address(dmiStartAddress);
  dmiData.set_end_address(dmiEndAddress);
  dmiData.set_dmi_ptr(dmiPtr);
  return returnStatus;
}

void axi_bus_base1_pv::clip_the_range(sc_dt::uint64 address,
                                            sc_dt::uint64 &dmiStartAddress,
                                            sc_dt::uint64 &dmiEndAddress,
                                            unsigned char* &dmiPtr,
                                            long slavePortIndex,
                                            signed long long offset) {
  sc_dt::uint64 slaveStartAddress = 0;
  sc_dt::uint64 slaveEndAddress = 0;
  bool subtractBaseAddress = true;
  decoder->getSlaveRangeByAddress(slavePortIndex, address, slaveStartAddress, slaveEndAddress, subtractBaseAddress);
  if (subtractBaseAddress) {
    sc_dt::uint64 translatedStartAddress = 0;
    sc_dt::uint64 translatedEndAddress = slaveEndAddress - slaveStartAddress;
    if (dmiEndAddress > translatedEndAddress)
      dmiEndAddress = translatedEndAddress;
    
    dmiStartAddress += (slaveStartAddress);
    dmiEndAddress += (slaveStartAddress);
  } else {
    if (slaveStartAddress > dmiStartAddress) {
      if (slaveStartAddress < dmiEndAddress) {
        dmiPtr += slaveStartAddress - dmiStartAddress;
        dmiStartAddress = slaveStartAddress;
      }
    }
    if (dmiEndAddress > slaveEndAddress) {
      if (slaveEndAddress > dmiStartAddress)
        dmiEndAddress = slaveEndAddress;
    }
  }
  // add the offset if from vmap parameter
  
  dmiStartAddress += (offset);
  dmiEndAddress += (offset);
}

void axi_bus_base1_pv::invalidate_direct_mem_ptr_callback(unsigned master_index, sc_dt::uint64 start_range, sc_dt::uint64 end_range) {
  config::uint64 startAddress;
  config::uint64 endAddress;
  bool substractBaseAddress;  
  decoder->getSlaveRange(master_index, startAddress, endAddress, substractBaseAddress);
  sc_dt::uint64 current_start_range = start_range;
  sc_dt::uint64 current_end_range = end_range;
  unsigned char* dmi_ptr = 0;
  clip_the_range(startAddress, current_start_range, current_end_range, dmi_ptr, master_index, 0);
  sc_dt::uint64 original_address = 0;
original_address = decoder->getOriginalAddress(driver_idx, current_start_range);
  invalidate_direct_mem_ptr(driver_idx, original_address, original_address + current_end_range - current_start_range);original_address = decoder->getOriginalAddress(jpeg_dma_idx, current_start_range);
  invalidate_direct_mem_ptr(jpeg_dma_idx, original_address, original_address + current_end_range - current_start_range);
}


void axi_bus_base1_pv::sram_master_invalidate_direct_mem_ptr_callback(sc_dt::uint64 start_range, sc_dt::uint64 end_range) {
    invalidate_direct_mem_ptr_callback(sram_master_idx, start_range, end_range);
  }
void axi_bus_base1_pv::jpeg_regs_invalidate_direct_mem_ptr_callback(sc_dt::uint64 start_range, sc_dt::uint64 end_range) {
    invalidate_direct_mem_ptr_callback(jpeg_regs_idx, start_range, end_range);
  }

void axi_bus_base1_pv::invalidate_direct_mem_ptr(unsigned target_index, sc_dt::uint64 start_range, sc_dt::uint64 end_range) {
  switch(target_index) {
  case driver_idx :
    driver->invalidate_direct_mem_ptr(start_range, end_range);
    break;
  case jpeg_dma_idx :
    jpeg_dma->invalidate_direct_mem_ptr(start_range, end_range);
    break;
  }
}

/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file is write protected.
//* DO NOT MODIFY THIS FILE.
//*
//* This file is used only for learning the component.
//* It contains the machine architecture class for your axi_bus model.
//* 
//* Model Builder version: 4.1.0
//* Generated on: Jan. 27, 2016 03:08:49 PM, (user: mbradley)
//*>

#include "axi_bus_model.h"
#include "model_builder.h"

using namespace ::mb::utl::minmax;

axi_bus_machine_arch::axi_bus_machine_arch()
    : MachineArch(4, 0) {
        reset();
    }
    
    ////////////////////////////////////////////////////////////////////
    //   function for port: driver
    ////////////////////////////////////////////////////////////////////
    
    
    //////
    // functions for port: driver, transaction: WRITE
    //////
    
    void axi_bus_machine_arch::transaction_instance__driver__WRITE
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    //////
    // functions for port: driver, transaction: READ
    //////
    
    void axi_bus_machine_arch::transaction_instance__driver__READ
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    ////////////////////////////////////////////////////////////////////
    //   function for port: sram_master
    ////////////////////////////////////////////////////////////////////
    
    
    //////
    // functions for port: sram_master, transaction: WRITE
    //////
    
    void axi_bus_machine_arch::transaction_instance__sram_master__WRITE
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    //////
    // functions for port: sram_master, transaction: READ
    //////
    
    void axi_bus_machine_arch::transaction_instance__sram_master__READ
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    ////////////////////////////////////////////////////////////////////
    //   function for port: jpeg_dma
    ////////////////////////////////////////////////////////////////////
    
    
    //////
    // functions for port: jpeg_dma, transaction: WRITE
    //////
    
    void axi_bus_machine_arch::transaction_instance__jpeg_dma__WRITE
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    //////
    // functions for port: jpeg_dma, transaction: READ
    //////
    
    void axi_bus_machine_arch::transaction_instance__jpeg_dma__READ
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    ////////////////////////////////////////////////////////////////////
    //   function for port: jpeg_regs
    ////////////////////////////////////////////////////////////////////
    
    
    //////
    // functions for port: jpeg_regs, transaction: WRITE
    //////
    
    void axi_bus_machine_arch::transaction_instance__jpeg_regs__WRITE
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    //////
    // functions for port: jpeg_regs, transaction: READ
    //////
    
    void axi_bus_machine_arch::transaction_instance__jpeg_regs__READ
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }

void axi_bus_machine_arch::startTransaction(unsigned portIndex, unsigned transactionIndex, sc_dt::uint64 currentTime) {
  switch(portIndex) {
    case(0) : break;
    case(1) : break;
    case(2) : break;
    case(3) : break;
    default: break;
  }
}
VariableBase* axi_bus_machine_arch::getVariableBasePtrByName(const char* name) {
  return NULL;
}
Register* axi_bus_machine_arch::getRegisterByName(const char* name) {
  return 0;
}
void axi_bus_machine_arch::reset() { 
    MachineArch::reset();
}
bool axi_bus_machine_arch::getAddressRange(unsigned portIndex, sc_dt::uint64& begin, sc_dt::uint64& end) {
    switch(portIndex) {
        case(0) :   return false;
        case(1) :   return false;
        case(2) :   return false;
        case(3) :   return false;
        default: break;
    }
    return false; 
}
void axi_bus_machine_arch::callTransaction(unsigned portIndex, unsigned transactionIndex, sc_dt::uint64 address, sc_dt::uint64 size, sc_dt::uint64 data, bool has_been_error, sc_dt::uint64 currentTime) {
    switch(portIndex) {
        case(0) : { //port: driver
            switch(transactionIndex) {
                case(0) : { //transaction: WRITE
                    this->transaction_instance__driver__WRITE
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
                case(1) : { //transaction: READ
                    this->transaction_instance__driver__READ
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
            }
            break;
        }
        case(1) : { //port: sram_master
            switch(transactionIndex) {
                case(0) : { //transaction: WRITE
                    this->transaction_instance__sram_master__WRITE
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
                case(1) : { //transaction: READ
                    this->transaction_instance__sram_master__READ
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
            }
            break;
        }
        case(2) : { //port: jpeg_dma
            switch(transactionIndex) {
                case(0) : { //transaction: WRITE
                    this->transaction_instance__jpeg_dma__WRITE
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
                case(1) : { //transaction: READ
                    this->transaction_instance__jpeg_dma__READ
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
            }
            break;
        }
        case(3) : { //port: jpeg_regs
            switch(transactionIndex) {
                case(0) : { //transaction: WRITE
                    this->transaction_instance__jpeg_regs__WRITE
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
                case(1) : { //transaction: READ
                    this->transaction_instance__jpeg_regs__READ
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
            }
            break;
        }
        default: break;
    }
}


/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

#include "axi_bus_model.h"

using namespace esl::tlm_sim;
using namespace esl::sc_sim;
using namespace std;
using namespace sc_dt;
using namespace sc_core;

void axi_bus_t_base::createDecoder(void* userRunningModel) {
  long* portLayers = 0;
  long* readAddressLayers = 0;
  long* writeAddressLayers = 0;
  long* readDataLayers = 0;
  long* writeDataLayers = 0;
  long** mastersVmap = 0;
  if (isMultiChannel && layers && *layers == 0)
    Papoulis_ParseLayersFile(userRunningModel,
                             "driver: sram_master, jpeg_regs; jpeg_dma: sram_master, jpeg_regs; ",
                             slave_sets,
                             "",
                             portLayers,
                             readAddressLayers,
                             writeAddressLayers,
                             readDataLayers,
                             writeDataLayers,
                             mastersVmap);
    
  else
    Papoulis_ParseLayersFile(userRunningModel,
                             layers,
                             slave_sets,
                             "",
                             portLayers,
                             readAddressLayers,
                             writeAddressLayers,
                             readDataLayers,
                             writeDataLayers,
                             mastersVmap);

  m_decoder = new esl::sc_sim::user_model::Decoder(2, mastersVmap, port_count, write_broadcast);
  if (!m_arbiter)
    m_arbiter = new esl::sc_sim::user_model::Arbiter(new esl::sc_sim::ArbiterScheme());
  m_arbiter->updateTables(port_count);
  m_arbiter->setDecoder(m_decoder);

  unsigned masterIndex = 0;
  for (unsigned u = 0; u < get_port_count(); u++)
    if (is_master(u)) {
      masterIndex = u;
      break;
    }

  m_decoder->insertPortName("driver");
  m_decoder->insertPortName("sram_master");
  m_decoder->insertPortName("jpeg_dma");
  m_decoder->insertPortName("jpeg_regs");
  
  std::vector<esl::sc_sim::SystemCChannel*>* channels = getReadAndWriteChannels(masterIndex);
  if (channels->size() == 1) {
    esl::sc_sim::SystemCChannel* channel = (*channels)[0];
    std::vector<esl::sc_sim::protocol_phase> protocol_phases = channel->getProtocolPhases();
    for(unsigned u = 0; u < protocol_phases.size(); u += 2) {
      m_arbiter->addChannel(tlm::TLM_IGNORE_COMMAND, protocol_phases[u].get_phase(), protocol_phases[u].is_input());
    }
  } else if (channels->size() == 2) {
    esl::sc_sim::SystemCChannel* channel = (*channels)[0];
    std::vector<esl::sc_sim::protocol_phase> protocol_phases = channel->getProtocolPhases();
    for(unsigned u = 0; u < protocol_phases.size(); u += 2) {
      m_arbiter->addChannel(tlm::TLM_READ_COMMAND, protocol_phases[u].get_phase(), protocol_phases[u].is_input());
    }
    channel = (*channels)[1];
    protocol_phases = channel->getProtocolPhases();
    for(unsigned u = 0; u < protocol_phases.size(); u += 2) {
      m_arbiter->addChannel(tlm::TLM_WRITE_COMMAND, protocol_phases[u].get_phase(), protocol_phases[u].is_input());
    }
  }

  if(isMultiChannel)
    m_arbiter->setMultiChannel();
  unsigned* pendings = new unsigned[port_count];
  pendings[driver] = Papoulis_GetPending((void*)getUserRunningModel(), driver);
  pendings[sram_master] = Papoulis_GetPending((void*)getUserRunningModel(), sram_master);
  pendings[jpeg_dma] = Papoulis_GetPending((void*)getUserRunningModel(), jpeg_dma);
  pendings[jpeg_regs] = Papoulis_GetPending((void*)getUserRunningModel(), jpeg_regs);
  m_arbiter->setPendings(pendings);
  sc_dt::uint64 base_address = 0;
  if (sram_master_base_address == 0xffffffff && 
      sizeof(sram_master_base_address) == 4)
    base_address = 0xffffffffffffffffULL;
  else
    base_address = sram_master_base_address;
  m_decoder->registerSlavePort(sram_master,
                               base_address,
                               sram_master_size,
                               sram_master_subtract_base_address);
  m_decoder->parseSlavePortAdditionalRanges(sram_master,
                                            "sram_master",
                                            sram_master_additional_ranges,
                                            sram_master_subtract_base_address);
  m_decoder->setSecure(sram_master, sram_master_secure, config::uint32_max);

  if (jpeg_regs_base_address == 0xffffffff && 
      sizeof(jpeg_regs_base_address) == 4)
    base_address = 0xffffffffffffffffULL;
  else
    base_address = jpeg_regs_base_address;
  m_decoder->registerSlavePort(jpeg_regs,
                               base_address,
                               jpeg_regs_size,
                               jpeg_regs_subtract_base_address);
  m_decoder->parseSlavePortAdditionalRanges(jpeg_regs,
                                            "jpeg_regs",
                                            jpeg_regs_additional_ranges,
                                            jpeg_regs_subtract_base_address);
  m_decoder->setSecure(jpeg_regs, jpeg_regs_secure, config::uint32_max);

  m_decoder->registerPortPriorityAndData(driver, driver_priority, (void*)0);
  m_decoder->registerPortPriorityAndData(sram_master, sram_master_priority, (void*)0);
  m_decoder->parseVmapString(driver, driver_vmap, "driver_vmap");
  m_decoder->registerPortPriorityAndData(jpeg_dma, jpeg_dma_priority, (void*)0);
  m_decoder->registerPortPriorityAndData(jpeg_regs, jpeg_regs_priority, (void*)0);
  m_decoder->parseVmapString(jpeg_dma, jpeg_dma_vmap, "jpeg_dma_vmap");
  m_decoder->checkConsistency(name());
  long portCount = 2 + 2;
  m_arbiter->generateLayerTable(portCount, portLayers, readAddressLayers, writeAddressLayers, readDataLayers, writeDataLayers);
}

void axi_bus_t_base::schedule_axi_READ
(long portIndex,
 sc_dt::uint64 delay,
 long& transactionSize,
 esl::include::transaction_power& power , long TR_ID, long ARADDR, long* RDATA, long ARSIZE, long block_size, long ARBURST, long ARLEN, long ARLOCK) {
  scheduleGenericTransaction(portIndex,
                             0,
                             ARADDR,
                             (unsigned char*)RDATA,
                             transactionSize,
                             block_size,
                             0,
                             papoulis::getSimulationTime() + delay,
                             0,
                             0);
}
void axi_bus_t_base::schedule_axi_WRITE
(long portIndex,
 sc_dt::uint64 delay,
 long& transactionSize,
 esl::include::transaction_power& power , long TR_ID, long AWADDR, long* WDATA, long AWSIZE, long block_size, long AWBURST, long AWLEN, long AWLOCK) {
  scheduleGenericTransaction(portIndex,
                             1,
                             AWADDR,
                             (unsigned char*)WDATA,
                             transactionSize,
                             block_size,
                             0,
                             papoulis::getSimulationTime() + delay,
                             0,
                             0);
}

axi_bus_t_base::axi_bus_t_base(sc_module_name& module_name, long simulation,
                                           esl::sc_sim::user_model::Arbiter* arbiter) :
  papoulis::PapoulisBusBaseModel(module_name, arbiter, 1, 0),
  SD_INITIALIZE_PARAMETER(clock, sc_core::sc_time(10, sc_core::SC_NS)),
  SD_INITIALIZE_PARAMETER(axi_clock, clock),
  SD_INITIALIZE_PARAMETER(nominal_voltage, 1),
  SD_INITIALIZE_PARAMETER(verbose_parameters, true),
  SD_INITIALIZE_PARAMETER(dmi_enabled, true),
  SD_INITIALIZE_PARAMETER(warning_level, "WARNING"),
  SD_INITIALIZE_PARAMETER(layers, ""),
  SD_INITIALIZE_PARAMETER(slave_sets, ""),
  SD_INITIALIZE_PARAMETER(write_broadcast, 0),
  SD_INITIALIZE_PARAMETER(driver_priority, 0),
  SD_INITIALIZE_PARAMETER(driver_vmap, ""),
  SD_INITIALIZE_PARAMETER(sram_master_priority, 0),
  SD_INITIALIZE_PARAMETER(sram_master_base_address, 0),
  SD_INITIALIZE_PARAMETER(sram_master_size, 0x20000000),
  SD_INITIALIZE_PARAMETER(sram_master_subtract_base_address, 1),
  SD_INITIALIZE_PARAMETER(sram_master_secure, 0),
  SD_INITIALIZE_PARAMETER(sram_master_additional_ranges, ""),
  SD_INITIALIZE_PARAMETER(sram_master_latency, 0),
  SD_INITIALIZE_PARAMETER(jpeg_dma_priority, 0),
  SD_INITIALIZE_PARAMETER(jpeg_dma_vmap, ""),
  SD_INITIALIZE_PARAMETER(jpeg_regs_priority, 0),
  SD_INITIALIZE_PARAMETER(jpeg_regs_base_address, 0xE0000000),
  SD_INITIALIZE_PARAMETER(jpeg_regs_size, 0x100),
  SD_INITIALIZE_PARAMETER(jpeg_regs_subtract_base_address, 1),
  SD_INITIALIZE_PARAMETER(jpeg_regs_secure, 0),
  SD_INITIALIZE_PARAMETER(jpeg_regs_additional_ranges, ""),
  SD_INITIALIZE_PARAMETER(jpeg_regs_latency, 0),
        m_simulation(simulation), m_machine_arch(new axi_bus_machine_arch()), m_current_request(0)
{
  fix_clock_parameter(axi_clock, "axi_clock");
  fix_clock_parameter(axi_clock, "axi_clock");
  fix_clock_parameter(axi_clock, "axi_clock");
  fix_clock_parameter(axi_clock, "axi_clock");
  bool separate_read_channel = false;
  bool separate_write_channel = false;
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[driver].port_name = "driver";
  separate_read_channel = true;
  port_descriptions[driver].port_kind = PortDescription::READ_CHANNEL_PORT;
  separate_write_channel = true;
  port_descriptions[driver].port_kind = PortDescription::WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[driver].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[driver].is_master_port = 0;
  port_descriptions[driver].is_signal_port = 0;
  port_descriptions[driver].port_width = ((32 + 7) >> 3);
  port_descriptions[driver].port_width_in_bits = 32;
  port_descriptions[driver].protocol_name = "axi";
  port_descriptions[driver].ipxactBusDef.vendor = "amba.com";
  port_descriptions[driver].ipxactBusDef.library = "AMBA3";
  port_descriptions[driver].ipxactBusDef.name = "AXI";
  port_descriptions[driver].ipxactBusDef.version = "r1p0_5"; 
  port_descriptions[driver].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[driver].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[driver].ipxactAbstrDef.name = "AXI_tlm20";
  port_descriptions[driver].ipxactAbstrDef.version = "1.0";
  port_descriptions[driver].port_must_bind = 0;
  port_descriptions[driver].params_count = 8;
  port_descriptions[driver].pending = 1;
  port_descriptions[driver].read_data_queue_size = 0;
  port_descriptions[driver].write_data_queue_size = 0;
  port_descriptions[driver].clock = axi_clock;
  port_descriptions[driver].add_read_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !0, 0);
  port_descriptions[driver].add_read_phase(tlm::tlm_phase(tlm::END_REQ), !1, 0);
  port_descriptions[driver].add_read_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !1, 1);
  port_descriptions[driver].add_read_phase(tlm::tlm_phase(tlm::END_RESP), !0, 1);
  port_descriptions[driver].add_write_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !0, 0);
  port_descriptions[driver].add_write_phase(tlm::tlm_phase(tlm::END_REQ), !1, 0);
  port_descriptions[driver].add_write_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !1, 1);
  port_descriptions[driver].add_write_phase(tlm::tlm_phase(tlm::END_RESP), !0, 1);
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[sram_master].port_name = "sram_master";
  separate_read_channel = true;
  port_descriptions[sram_master].port_kind = PortDescription::READ_CHANNEL_PORT;
  separate_write_channel = true;
  port_descriptions[sram_master].port_kind = PortDescription::WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[sram_master].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[sram_master].is_master_port = 1;
  port_descriptions[sram_master].is_signal_port = 0;
  port_descriptions[sram_master].port_width = ((32 + 7) >> 3);
  port_descriptions[sram_master].port_width_in_bits = 32;
  port_descriptions[sram_master].protocol_name = "axi";
  port_descriptions[sram_master].ipxactBusDef.vendor = "amba.com";
  port_descriptions[sram_master].ipxactBusDef.library = "AMBA3";
  port_descriptions[sram_master].ipxactBusDef.name = "AXI";
  port_descriptions[sram_master].ipxactBusDef.version = "r1p0_5"; 
  port_descriptions[sram_master].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[sram_master].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[sram_master].ipxactAbstrDef.name = "AXI_tlm20";
  port_descriptions[sram_master].ipxactAbstrDef.version = "1.0";
  port_descriptions[sram_master].port_must_bind = 0;
  port_descriptions[sram_master].params_count = 8;
  port_descriptions[sram_master].pending = 1;
  port_descriptions[sram_master].read_data_queue_size = 0;
  port_descriptions[sram_master].write_data_queue_size = 0;
  port_descriptions[sram_master].clock = axi_clock;
  port_descriptions[sram_master].add_read_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !1, 0);
  port_descriptions[sram_master].add_read_phase(tlm::tlm_phase(tlm::END_REQ), !0, 0);
  port_descriptions[sram_master].add_read_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !0, 1);
  port_descriptions[sram_master].add_read_phase(tlm::tlm_phase(tlm::END_RESP), !1, 1);
  port_descriptions[sram_master].add_write_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !1, 0);
  port_descriptions[sram_master].add_write_phase(tlm::tlm_phase(tlm::END_REQ), !0, 0);
  port_descriptions[sram_master].add_write_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !0, 1);
  port_descriptions[sram_master].add_write_phase(tlm::tlm_phase(tlm::END_RESP), !1, 1);
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[jpeg_dma].port_name = "jpeg_dma";
  separate_read_channel = true;
  port_descriptions[jpeg_dma].port_kind = PortDescription::READ_CHANNEL_PORT;
  separate_write_channel = true;
  port_descriptions[jpeg_dma].port_kind = PortDescription::WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[jpeg_dma].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[jpeg_dma].is_master_port = 0;
  port_descriptions[jpeg_dma].is_signal_port = 0;
  port_descriptions[jpeg_dma].port_width = ((32 + 7) >> 3);
  port_descriptions[jpeg_dma].port_width_in_bits = 32;
  port_descriptions[jpeg_dma].protocol_name = "axi";
  port_descriptions[jpeg_dma].ipxactBusDef.vendor = "amba.com";
  port_descriptions[jpeg_dma].ipxactBusDef.library = "AMBA3";
  port_descriptions[jpeg_dma].ipxactBusDef.name = "AXI";
  port_descriptions[jpeg_dma].ipxactBusDef.version = "r1p0_5"; 
  port_descriptions[jpeg_dma].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[jpeg_dma].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[jpeg_dma].ipxactAbstrDef.name = "AXI_tlm20";
  port_descriptions[jpeg_dma].ipxactAbstrDef.version = "1.0";
  port_descriptions[jpeg_dma].port_must_bind = 0;
  port_descriptions[jpeg_dma].params_count = 8;
  port_descriptions[jpeg_dma].pending = 1;
  port_descriptions[jpeg_dma].read_data_queue_size = 0;
  port_descriptions[jpeg_dma].write_data_queue_size = 0;
  port_descriptions[jpeg_dma].clock = axi_clock;
  port_descriptions[jpeg_dma].add_read_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !0, 0);
  port_descriptions[jpeg_dma].add_read_phase(tlm::tlm_phase(tlm::END_REQ), !1, 0);
  port_descriptions[jpeg_dma].add_read_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !1, 1);
  port_descriptions[jpeg_dma].add_read_phase(tlm::tlm_phase(tlm::END_RESP), !0, 1);
  port_descriptions[jpeg_dma].add_write_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !0, 0);
  port_descriptions[jpeg_dma].add_write_phase(tlm::tlm_phase(tlm::END_REQ), !1, 0);
  port_descriptions[jpeg_dma].add_write_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !1, 1);
  port_descriptions[jpeg_dma].add_write_phase(tlm::tlm_phase(tlm::END_RESP), !0, 1);
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[jpeg_regs].port_name = "jpeg_regs";
  separate_read_channel = true;
  port_descriptions[jpeg_regs].port_kind = PortDescription::READ_CHANNEL_PORT;
  separate_write_channel = true;
  port_descriptions[jpeg_regs].port_kind = PortDescription::WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[jpeg_regs].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[jpeg_regs].is_master_port = 1;
  port_descriptions[jpeg_regs].is_signal_port = 0;
  port_descriptions[jpeg_regs].port_width = ((32 + 7) >> 3);
  port_descriptions[jpeg_regs].port_width_in_bits = 32;
  port_descriptions[jpeg_regs].protocol_name = "axi";
  port_descriptions[jpeg_regs].ipxactBusDef.vendor = "amba.com";
  port_descriptions[jpeg_regs].ipxactBusDef.library = "AMBA3";
  port_descriptions[jpeg_regs].ipxactBusDef.name = "AXI";
  port_descriptions[jpeg_regs].ipxactBusDef.version = "r1p0_5"; 
  port_descriptions[jpeg_regs].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[jpeg_regs].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[jpeg_regs].ipxactAbstrDef.name = "AXI_tlm20";
  port_descriptions[jpeg_regs].ipxactAbstrDef.version = "1.0";
  port_descriptions[jpeg_regs].port_must_bind = 0;
  port_descriptions[jpeg_regs].params_count = 8;
  port_descriptions[jpeg_regs].pending = 1;
  port_descriptions[jpeg_regs].read_data_queue_size = 0;
  port_descriptions[jpeg_regs].write_data_queue_size = 0;
  port_descriptions[jpeg_regs].clock = axi_clock;
  port_descriptions[jpeg_regs].add_read_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !1, 0);
  port_descriptions[jpeg_regs].add_read_phase(tlm::tlm_phase(tlm::END_REQ), !0, 0);
  port_descriptions[jpeg_regs].add_read_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !0, 1);
  port_descriptions[jpeg_regs].add_read_phase(tlm::tlm_phase(tlm::END_RESP), !1, 1);
  port_descriptions[jpeg_regs].add_write_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !1, 0);
  port_descriptions[jpeg_regs].add_write_phase(tlm::tlm_phase(tlm::END_REQ), !0, 0);
  port_descriptions[jpeg_regs].add_write_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !0, 1);
  port_descriptions[jpeg_regs].add_write_phase(tlm::tlm_phase(tlm::END_RESP), !1, 1);

  port_descriptions[driver].default_read_transaction_name = "READ";
  port_descriptions[sram_master].default_read_transaction_name = "READ";
  port_descriptions[jpeg_dma].default_read_transaction_name = "READ";
  port_descriptions[jpeg_regs].default_read_transaction_name = "READ";

  port_descriptions[driver].default_write_transaction_name = "WRITE";
  port_descriptions[sram_master].default_write_transaction_name = "WRITE";
  port_descriptions[jpeg_dma].default_write_transaction_name = "WRITE";
  port_descriptions[jpeg_regs].default_write_transaction_name = "WRITE";

  fix_internal_clock_parameter(clock, "clock");
  set_ports(mb::sysc::sc_time_to_ps(clock), port_count, port_descriptions);
  
  esl::tlm_sim::UserRunningModel* model = Papoulis_CreateUserRunningModel(name(),
                                                                          0,
                                                                          this,
                                                                          simulation,
                                                                          true,
                                                                          false);
  setUserRunningModel(model, false);
  createDecoder(model);
  registerParameter("clock", "sc_core::sc_time", sdGetParameterAsConstString("clock"));
  registerParameter("axi_clock", "sc_core::sc_time", sdGetParameterAsConstString("axi_clock"));
  registerParameter("nominal_voltage", "double", sdGetParameterAsConstString("nominal_voltage"));
  registerParameter("verbose_parameters", "bool", sdGetParameterAsConstString("verbose_parameters"));
  registerParameter("dmi_enabled", "bool", sdGetParameterAsConstString("dmi_enabled"));
  registerParameter("warning_level", "const char*", sdGetParameterAsConstString("warning_level"));
  registerParameter("layers", "const char*", sdGetParameterAsConstString("layers"));
  registerParameter("slave_sets", "const char*", sdGetParameterAsConstString("slave_sets"));
  registerParameter("write_broadcast", "unsigned int", sdGetParameterAsConstString("write_broadcast"));
  registerParameter("driver_priority", "unsigned int", sdGetParameterAsConstString("driver_priority"));
  registerParameter("driver_vmap", "const char*", sdGetParameterAsConstString("driver_vmap"));
  registerParameter("sram_master_priority", "unsigned int", sdGetParameterAsConstString("sram_master_priority"));
  registerParameter("sram_master_base_address", "unsigned long long", sdGetParameterAsConstString("sram_master_base_address"));
  registerParameter("sram_master_size", "unsigned long long", sdGetParameterAsConstString("sram_master_size"));
  registerParameter("sram_master_subtract_base_address", "unsigned int", sdGetParameterAsConstString("sram_master_subtract_base_address"));
  registerParameter("sram_master_secure", "unsigned int", sdGetParameterAsConstString("sram_master_secure"));
  registerParameter("sram_master_additional_ranges", "const char*", sdGetParameterAsConstString("sram_master_additional_ranges"));
  registerParameter("sram_master_latency", "unsigned int", sdGetParameterAsConstString("sram_master_latency"));
  registerParameter("jpeg_dma_priority", "unsigned int", sdGetParameterAsConstString("jpeg_dma_priority"));
  registerParameter("jpeg_dma_vmap", "const char*", sdGetParameterAsConstString("jpeg_dma_vmap"));
  registerParameter("jpeg_regs_priority", "unsigned int", sdGetParameterAsConstString("jpeg_regs_priority"));
  registerParameter("jpeg_regs_base_address", "unsigned long long", sdGetParameterAsConstString("jpeg_regs_base_address"));
  registerParameter("jpeg_regs_size", "unsigned long long", sdGetParameterAsConstString("jpeg_regs_size"));
  registerParameter("jpeg_regs_subtract_base_address", "unsigned int", sdGetParameterAsConstString("jpeg_regs_subtract_base_address"));
  registerParameter("jpeg_regs_secure", "unsigned int", sdGetParameterAsConstString("jpeg_regs_secure"));
  registerParameter("jpeg_regs_additional_ranges", "const char*", sdGetParameterAsConstString("jpeg_regs_additional_ranges"));
  registerParameter("jpeg_regs_latency", "unsigned int", sdGetParameterAsConstString("jpeg_regs_latency"));
  

  delay_policy* delay_policy_handle = 0;

  delay_policy_handle = new delay_policy(model,
                                         "driver",
                                         0,
                                         0,
                                         mb::tlm20::SYNC_BEGIN);
  delay_policy_handle->set_power(0);
  m_delay_vector.push_back(delay_policy_handle);
  delay_policy_handle = new delay_policy(model,
                                         "jpeg_dma",
                                         0,
                                         0,
                                         mb::tlm20::SYNC_BEGIN);
  delay_policy_handle->set_power(0);
  m_delay_vector.push_back(delay_policy_handle);
  unsigned pipeline_policy_index = 0;
  pipeline_policy* pipeline_policy_handle = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "driver";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "sram_master";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(sram_master_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "driver";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "jpeg_regs";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(jpeg_regs_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "jpeg_dma";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "sram_master";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(sram_master_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "jpeg_dma";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "jpeg_regs";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(jpeg_regs_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  set_user_pipeline_policies(user_pipeline_policy_count, user_pipeline_policy_descriptions);
  
  constant_global_power_policy* p = new constant_global_power_policy(model);
  
  
  
  set_global_power_policy(p);
}

void axi_bus_t_base::update_pipeline_parameters(esl::sc_sim::pipeline_policy* handle) {
  if (m_pipeline_vector.size() == 0)
    return;

  if (handle == m_pipeline_vector[0]) {
    handle->setLatency(sram_master_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[1]) {
    handle->setLatency(jpeg_regs_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[2]) {
    handle->setLatency(sram_master_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[3]) {
    handle->setLatency(jpeg_regs_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }

}

void axi_bus_t_base::update_delay_parameters(esl::sc_sim::delay_policy* handle) {
  if (m_delay_vector.size() == 0)
    return;

  if (handle == m_delay_vector[0]) {
    handle->set_inner_delay(0);
    handle->set_start_delay(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_delay_vector[1]) {
    handle->set_inner_delay(0);
    handle->set_start_delay(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
}

void axi_bus_t_base::update_bus_parameters(esl::sc_sim::uniform_bus_policy* handle) {
  if (m_bus_vector.size() == 0)
    return;

}


void axi_bus_t_base::vista_trace(bool isStart, request_type* request, long portIndex, sc_dt::uint64 startTime) {
  
  sc_dt::uint64 local_params[8];
  for (unsigned u = 0; u < 8; u++)
    local_params[u] = 0;
  
  sc_dt::uint64 address = request->get_address();
  
  local_params[1] = address;
  
  local_params[4] = get_port_width(portIndex);
  sc_dt::uint64* parameters = local_params;
  long size = request->get_data_length();
  
  bool isWrite = request->is_write();
  m_current_request = request;
  if(isStart) {
    this->print_transaction(portIndex, isWrite, true, address, size);
    if (isWrite) {
      if (is_master(portIndex)) {
        this->accept_axi_WRITE
          (portIndex, 
           startTime, 
           size,
           parameters[0],
           parameters[1],
           parameters[2],
           parameters[3],
           parameters[4],
           parameters[5],
           parameters[6],
           parameters[7]);
      } else {
        this->accept_axi_WRITE
          (portIndex, 
           startTime, 
           size,
           parameters[0],
           parameters[1],
           parameters[2],
           parameters[3],
           parameters[4],
           parameters[5],
           parameters[6],
           parameters[7]);
      }
    } else {
      if (is_master(portIndex)) {
        this->accept_axi_READ
          (portIndex, 
           startTime, 
           size,
           parameters[0],
           parameters[1],
           parameters[2],
           parameters[3],
           parameters[4],
           parameters[5],
           parameters[6],
           parameters[7]);
      } else {
        this->accept_axi_READ
          (portIndex, 
           startTime, 
           size,
           parameters[0],
           parameters[1],
           parameters[2],
           parameters[3],
           parameters[4],
           parameters[5],
           parameters[6],
           parameters[7]);
      }
    }
  } else {
    this->print_transaction(portIndex, isWrite, false, address, size);
    if (isWrite) {
      if (is_master(portIndex)) {
        this->end_axi_WRITE
          (portIndex, 
           startTime, 
           size,
           parameters[0],
           parameters[1],
           parameters[2],
           parameters[3],
           parameters[4],
           parameters[5],
           parameters[6],
           parameters[7]);
      } else {
        this->end_axi_WRITE
          (portIndex, 
           startTime, 
           size,
           parameters[0],
           parameters[1],
           parameters[2],
           parameters[3],
           parameters[4],
           parameters[5],
           parameters[6],
           parameters[7]);
      }
    } else {
      if (is_master(portIndex)) {
        this->end_axi_READ
          (portIndex, 
           startTime, 
           size,
           parameters[0],
           parameters[1],
           parameters[2],
           parameters[3],
           parameters[4],
           parameters[5],
           parameters[6],
           parameters[7]);
      } else {
        this->end_axi_READ
          (portIndex, 
           startTime, 
           size,
           parameters[0],
           parameters[1],
           parameters[2],
           parameters[3],
           parameters[4],
           parameters[5],
           parameters[6],
           parameters[7]);
      }
    }
  }
  m_current_request = 0;
}

request_type* axi_bus_t_base::get_current_request() {
  return m_current_request;
}

unsigned axi_bus_t_base::get_layer(unsigned port_index) {
  if (is_slave(port_index))
    return m_arbiter->get_slave_layer(port_index);
  return m_arbiter->get_master_layer(port_index);
}

unsigned axi_bus_t_base::get_slave_port_index() {
  if (!m_current_request) {
    printf("ERROR: when calling get_slave_port_index in %s\n", name());
    return (unsigned)(-1);
  }
  return  m_arbiter->getMasterIndexByRequestId(m_current_request);
}

void axi_bus_t_base::update_power_parameters(esl::sc_sim::power_policy* handle) {
  if (m_power_vector.size() == 0)
    return;

}



/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file is write protected.
//* DO NOT MODIFY THIS FILE.
//*
//* This file contains the PVT class for axi_bus.
//* It connects between the PV and T models.
//* Your top-level design should instantiate this model.
//* 
//* In order to synchronize the activty between the PV and the T models, every 
//* PV transaction is monitored and queued in the T sync ports.
//* Whenever a synchronization point is reached, the T models are executed and 
//* the corresponding T transactions are launched.
//* A synchronization point is reached whenever there is a wait statement on a testbench thread. 
//*
//* Model Builder version: 4.1.0
//* Generated on: Jan. 27, 2016 03:08:49 PM, (user: mbradley)
//*>

#include "axi_bus_model.h"

using namespace std;
using namespace sc_core;
using namespace sc_dt;


#include "axi_bus_pv.h"




// Constructor
axi_bus_pvt::axi_bus_pvt(sc_module_name module_name)
  : esl::sc_sim::PVTBaseModel(module_name, 0),
    axi_bus_pvt_param_defaults(this->name()),
    sram_master("sram_master"),
    jpeg_regs("jpeg_regs"),
    driver("driver"),
    jpeg_dma("jpeg_dma"), 
    sram_master_entry("unvisible_sram_master_entry"), 
    jpeg_regs_entry("unvisible_jpeg_regs_entry"),
    driver_entry("unvisible_driver_entry"),
    jpeg_dma_entry("unvisible_jpeg_dma_entry"),
    m_sram_master_nb_connector(*this),
    m_jpeg_regs_nb_connector(*this),
    m_driver_nb_connector(*this),
    m_jpeg_dma_nb_connector(*this)

{


  m_axi_bus_t = axi_bus_t_base::create_t("T", 1);
  m_axi_bus_pv = new axi_bus_pv("PV");
  bind();
}  


axi_bus_pvt::axi_bus_pvt(sc_module_name module_name, sc_core::sc_time clock_init, sc_core::sc_time axi_clock_init, double nominal_voltage_init, bool verbose_parameters_init, bool dmi_enabled_init, const char* warning_level_init, const char* layers_init, const char* slave_sets_init, unsigned int write_broadcast_init, unsigned int driver_priority_init, const char* driver_vmap_init, unsigned int sram_master_priority_init, unsigned long long sram_master_base_address_init, unsigned long long sram_master_size_init, unsigned int sram_master_subtract_base_address_init, unsigned int sram_master_secure_init, const char* sram_master_additional_ranges_init, unsigned int sram_master_latency_init, unsigned int jpeg_dma_priority_init, const char* jpeg_dma_vmap_init, unsigned int jpeg_regs_priority_init, unsigned long long jpeg_regs_base_address_init, unsigned long long jpeg_regs_size_init, unsigned int jpeg_regs_subtract_base_address_init, unsigned int jpeg_regs_secure_init, const char* jpeg_regs_additional_ranges_init, unsigned int jpeg_regs_latency_init)
  : esl::sc_sim::PVTBaseModel(module_name, 0),
  axi_bus_pvt_param_defaults(this->name(), clock_init, axi_clock_init, nominal_voltage_init, verbose_parameters_init, dmi_enabled_init, warning_level_init, layers_init, slave_sets_init, write_broadcast_init, driver_priority_init, driver_vmap_init, sram_master_priority_init, sram_master_base_address_init, sram_master_size_init, sram_master_subtract_base_address_init, sram_master_secure_init, sram_master_additional_ranges_init, sram_master_latency_init, jpeg_dma_priority_init, jpeg_dma_vmap_init, jpeg_regs_priority_init, jpeg_regs_base_address_init, jpeg_regs_size_init, jpeg_regs_subtract_base_address_init, jpeg_regs_secure_init, jpeg_regs_additional_ranges_init, jpeg_regs_latency_init),
    sram_master("sram_master"),
    jpeg_regs("jpeg_regs"),
    driver("driver"),
    jpeg_dma("jpeg_dma"), 
    sram_master_entry("unvisible_sram_master_entry"), 
    jpeg_regs_entry("unvisible_jpeg_regs_entry"),
    driver_entry("unvisible_driver_entry"),
    jpeg_dma_entry("unvisible_jpeg_dma_entry"),
    m_sram_master_nb_connector(*this),
    m_jpeg_regs_nb_connector(*this),
    m_driver_nb_connector(*this),
    m_jpeg_dma_nb_connector(*this)
{


  m_axi_bus_t = axi_bus_t_base::create_t("T", 1);
  m_axi_bus_pv = new axi_bus_pv("PV");
  bind();
} 

axi_bus_pvt::axi_bus_pvt(sc_module_name module_name,  std::vector<std::pair<char*, unsigned int> > &change_parameters)
  : esl::sc_sim::PVTBaseModel(module_name, 0),
  axi_bus_pvt_param_defaults(this->name(), change_parameters),
    sram_master("sram_master"),
    jpeg_regs("jpeg_regs"),
    driver("driver"),
    jpeg_dma("jpeg_dma"), 
    sram_master_entry("unvisible_sram_master_entry"), 
    jpeg_regs_entry("unvisible_jpeg_regs_entry"),
    driver_entry("unvisible_driver_entry"),
    jpeg_dma_entry("unvisible_jpeg_dma_entry"),
    m_sram_master_nb_connector(*this),
    m_jpeg_regs_nb_connector(*this),
    m_driver_nb_connector(*this),
    m_jpeg_dma_nb_connector(*this)
{


  m_axi_bus_t = axi_bus_t_base::create_t("T", 1);
  m_axi_bus_pv = new axi_bus_pv("PV");
  bind();
} 

axi_bus_pvt::~axi_bus_pvt() {
  remove_pending_scenes();
  delete m_axi_bus_t; delete m_axi_bus_pv;
}




void axi_bus_pvt::bind()
{
  /* connect pv to entry ports */
  
  
  getPV()->sram_master.bind(sram_master_entry);
  getPV()->jpeg_regs.bind(jpeg_regs_entry);
  driver_entry.bind(getPV()->driver);
  jpeg_dma_entry.bind(getPV()->jpeg_dma);   

  /* set callbacks on external and entry ports */ 

  driver.b_transport_cb.set(&driver_entry, &driver_entry_type::b_transport);
  driver.transport_dbg_cb.set(&driver_entry, &driver_entry_type::transport_dbg);
  driver.get_direct_mem_ptr_cb.set(&driver_entry, &driver_entry_type::get_direct_mem_ptr);

  jpeg_dma.b_transport_cb.set(&jpeg_dma_entry, &jpeg_dma_entry_type::b_transport);
  jpeg_dma.transport_dbg_cb.set(&jpeg_dma_entry, &jpeg_dma_entry_type::transport_dbg);
  jpeg_dma.get_direct_mem_ptr_cb.set(&jpeg_dma_entry, &jpeg_dma_entry_type::get_direct_mem_ptr);

  sram_master_entry.b_transport_cb.set(this, &self_type::b_transport_outside_sram_master);
  sram_master_entry.transport_dbg_cb.set(this, &self_type::transport_dbg_outside_sram_master);
  sram_master_entry.get_direct_mem_ptr_cb.set(&sram_master, &sram_master_type::get_direct_mem_ptr);

  jpeg_regs_entry.b_transport_cb.set(this, &self_type::b_transport_outside_jpeg_regs);
  jpeg_regs_entry.transport_dbg_cb.set(this, &self_type::transport_dbg_outside_jpeg_regs);
  jpeg_regs_entry.get_direct_mem_ptr_cb.set(&jpeg_regs, &jpeg_regs_type::get_direct_mem_ptr);

  
  /* connect t non blocking callbacks */

  sram_master.nb_transport_bw_cb.set(this, &self_type::receive_nb_transport_sram_master);
  getT()->set_port_cb(1, &m_sram_master_nb_connector);

  jpeg_regs.nb_transport_bw_cb.set(this, &self_type::receive_nb_transport_jpeg_regs);
  getT()->set_port_cb(3, &m_jpeg_regs_nb_connector);

  driver.nb_transport_fw_cb.set(this, &self_type::receive_nb_transport_driver);
  getT()->set_port_cb(0, &m_driver_nb_connector);

  jpeg_dma.nb_transport_fw_cb.set(this, &self_type::receive_nb_transport_jpeg_dma);
  getT()->set_port_cb(2, &m_jpeg_dma_nb_connector);

  driver_entry.invalidate_direct_mem_ptr_cb.set(&driver, &driver_type::invalidate_direct_mem_ptr);

  jpeg_dma_entry.invalidate_direct_mem_ptr_cb.set(&jpeg_dma, &jpeg_dma_type::invalidate_direct_mem_ptr);

  sram_master.invalidate_direct_mem_ptr_cb.set(&sram_master_entry, &sram_master_entry_type::invalidate_direct_mem_ptr);

  jpeg_regs.invalidate_direct_mem_ptr_cb.set(&jpeg_regs_entry, &jpeg_regs_entry_type::invalidate_direct_mem_ptr);

  /* check mb_event policies */
  m_axi_bus_t->check_mb_events();
}



void axi_bus_pvt::b_transport_outside_sram_master(tlm::tlm_generic_payload& p, sc_core::sc_time& t)
{
  if (!sram_master.get_interface()) {
    p.set_response_status(tlm::TLM_GENERIC_ERROR_RESPONSE);
    std::stringstream buf;
    buf << "The port " << sram_master.name() << " is unbound";
    mb::sysc::complain(buf.str().c_str(), sram_master.name());
    return;
  }
  sram_master.b_transport(p, t);
  
} 

unsigned int axi_bus_pvt::transport_dbg_outside_sram_master(tlm::tlm_generic_payload& p)
{
  if (!sram_master.get_interface()) {
     return 0;
  }
  return sram_master.transport_dbg(p);
  
}

void axi_bus_pvt::b_transport_outside_jpeg_regs(tlm::tlm_generic_payload& p, sc_core::sc_time& t)
{
  if (!jpeg_regs.get_interface()) {
    p.set_response_status(tlm::TLM_GENERIC_ERROR_RESPONSE);
    std::stringstream buf;
    buf << "The port " << jpeg_regs.name() << " is unbound";
    mb::sysc::complain(buf.str().c_str(), jpeg_regs.name());
    return;
  }
  jpeg_regs.b_transport(p, t);
  
} 

unsigned int axi_bus_pvt::transport_dbg_outside_jpeg_regs(tlm::tlm_generic_payload& p)
{
  if (!jpeg_regs.get_interface()) {
     return 0;
  }
  return jpeg_regs.transport_dbg(p);
  
}

